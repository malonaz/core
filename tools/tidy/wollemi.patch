diff --git a/domain/wollemi/service.go b/domain/wollemi/service.go
index d9bce4d..dbfec3e 100644
--- a/domain/wollemi/service.go
+++ b/domain/wollemi/service.go
@@ -136,7 +136,6 @@ func (this *Service) ReadDir(path string) (*Directory, error) {
 
 	for _, info := range infos {
 		name := info.Name()
-
 		dir.Files[name] = info
 
 		if info.IsDir() {
@@ -255,6 +254,13 @@ func (this *Service) ParseDir(buf *bytes.Buffer, dir *Directory) *Directory {
 
 			return dir
 		}
+		if !dir.HasGoFile {
+			build.GetRules(func (rule please.Rule) {
+				if _, ok := this.config.Gofmt.CodegenRuleFormatting[rule.Kind()]; ok {
+					dir.HasGoFile = true
+				}
+			})
+		}
 
 		dir.Build = build
 	}
diff --git a/domain/wollemi/service_format.go b/domain/wollemi/service_format.go
index 331b925..3c66fee 100644
--- a/domain/wollemi/service_format.go
+++ b/domain/wollemi/service_format.go
@@ -8,6 +8,7 @@ import (
 	"runtime"
 	"sort"
 	"strings"
+	"sync"
 
 	"github.com/tcncloud/wollemi/domain/optional"
 	"github.com/tcncloud/wollemi/ports/logging"
@@ -28,9 +29,24 @@ func newGoFormat(paths []string) *goFormat {
 		external:       map[string][]string{},
 		internal:       map[string]string{},
 		genfiles:       map[string]string{},
+		protoTemplateCodegen: map[string]struct{}{},
+		ruleToProtoTemplateCodegen: map[string][]string{},
 	}
 }
 
+func (gf *goFormat) IsGoRoot(path string, checkIfGoRoot func(string) bool) bool {
+	gf.mutex.RLock()
+	goroot, ok := gf.isGoroot[path]
+	gf.mutex.RUnlock()
+	if !ok {
+		goroot = checkIfGoRoot(path)
+		gf.mutex.Lock()
+		gf.isGoroot[path] = goroot
+		gf.mutex.Unlock()
+	}
+	return goroot
+}
+
 // goFormat contains all the state for formatting go rules i.e. the import path to target mapping, and the rules in the
 // targeted Please packages.
 type goFormat struct {
@@ -52,8 +68,13 @@ type goFormat struct {
 	// internal is a map of this projects imports paths to targets
 	internal map[string]string
 
-	// genfiles contain a map of generated files added via go_copy() to their build targets
+	// genfiles contain a map of generated files added via wollemi_go_file() to their build targets
 	genfiles map[string]string
+
+	// Store the protogen template codegens.
+	protoTemplateCodegen map[string]struct{}
+	ruleToProtoTemplateCodegen map[string][]string
+	mutex sync.RWMutex
 }
 
 // getTarget gets the target for an import path or generated file
@@ -66,6 +87,16 @@ func (this *Service) getTarget(config wollemi.Config, p string, isFile bool) str
 }
 
 func (this *Service) getTargetInternal(config wollemi.Config, path string, isFile bool, depth int) (string, string) {
+	// Apply import path remapping from config
+	if config.Gofmt.ImportPathRemapping != nil {
+		for prefix, replacement := range config.Gofmt.ImportPathRemapping {
+			if strings.HasPrefix(path, prefix) {
+				path = strings.Replace(path, prefix, replacement, 1)
+				break
+			}
+		}
+	}
+
 	if target, ok := config.KnownDependency[path]; ok {
 		return target, path
 	}
@@ -181,20 +212,11 @@ func (this *Service) parsePaths() error {
 				} {
 				Imports:
 					for _, godep := range imports {
-						goroot, ok := this.goFormat.isGoroot[godep]
-
-						if !ok {
-							goroot = this.golang.IsGoroot(godep)
-
-							this.goFormat.isGoroot[godep] = goroot
-						}
-
-						if goroot {
+						path := godep
+						if this.goFormat.IsGoRoot(path, this.golang.IsGoroot) {
 							continue
 						}
 
-						path := godep
-
 						if this.isInternal(path) {
 							path = strings.TrimPrefix(path, this.gopkg+"/")
 						} else {
@@ -316,19 +338,87 @@ func (this *Service) parsePaths() error {
 					case kind != "go_test":
 						this.goFormat.internal[filepath.Join(this.gopkg, path)] = "//" + target
 
-						if kind == "go_copy" {
-							this.goFormat.genfiles[path+".cp.go"] = target
+						if formatting, ok := this.config.Gofmt.CodegenRuleFormatting[kind]; ok {
+							filename := strings.ReplaceAll(formatting, "{{ name }}", path)
+							this.goFormat.genfiles[filename] = target
 						}
+
 					}
 				}
 			})
 		}
 	}
 
+	// AFTER the main parsing loop completes, do a second pass for proto templates
+	this.processProtoTemplateLibraries()
 	close(parse)
 	return nil
 }
 
+func (this *Service) processProtoTemplateLibraries() {
+	for _, dir := range this.goFormat.directories {
+		dir.Build.GetRules(func(rule please.Rule) {
+			if rule.Kind() != "go_proto_template_library" {
+				return
+			}
+
+			target := &please.Target{
+				Name: rule.AttrString("name"),
+				Path: dir.Path,
+			}
+
+			templateAttr := rule.AttrString("template")
+			if templateAttr == "" {
+				return
+			}
+
+			templateTarget := please.Split(templateAttr)
+			templateName := templateTarget.Name
+			if templateName == "" {
+				return
+			}
+
+			srcTargets := rule.AttrStrings("srcs")
+			for _, srcTarget := range srcTargets {
+				protoTarget := please.Split(srcTarget)
+
+				// Resolve the proto rule
+				var protoRule please.Rule
+				protoPath := protoTarget.Path
+				if protoPath == "" {
+					protoPath = dir.Path
+				}
+
+				if protoDir, ok := this.goFormat.directories[protoPath]; ok && protoDir.Build != nil {
+					protoRule = protoDir.Build.GetRule(protoTarget.Name)
+				}
+
+				if protoRule == nil {
+					continue
+				}
+
+				protoFiles := protoRule.AttrStrings("srcs")
+				for _, protoFile := range protoFiles {
+					if !strings.HasSuffix(protoFile, ".proto") {
+						continue
+					}
+
+					genFile := strings.TrimSuffix(protoFile, ".proto") + "_" + templateName + ".pb.go"
+					// The generated file path should be relative to the proto_library location
+					genPath := genFile
+
+					this.goFormat.protoTemplateCodegen[genPath] = struct{}{}
+					this.goFormat.genfiles[filepath.Join(dir.Path, genPath)] = target.String()
+					this.goFormat.ruleToProtoTemplateCodegen[target.Path + ":" + target.Name] = append(
+						this.goFormat.ruleToProtoTemplateCodegen[target.Path + ":" + target.Name],
+						genPath,
+					)
+				}
+			}
+		})
+	}
+}
+
 // formatDirs updated the BUILD file in the directories that were in the original paths
 func (this *Service) formatDirs() {
 	limiter := NewChanFunc(runtime.NumCPU()-1, 0)
@@ -341,7 +431,6 @@ func (this *Service) formatDirs() {
 
 		log := this.log.WithField("path", filepath.Join("/", path))
 		dir := dir
-
 		limiter.Run(func() {
 			this.formatDir(log, dir)
 
@@ -392,7 +481,7 @@ func (this *Service) GoFormat(config wollemi.Config, paths []string) error {
 	this.goFormat = newGoFormat(this.normalizePaths(paths))
 	defer this.goFormat.resolveLimiter.Close()
 
-	this.config = config
+	this.config = this.filesystem.Config("").Merge(config)
 
 	log := this.log.WithField("rewrite", this.config.Gofmt.GetRewrite())
 
@@ -422,9 +511,8 @@ func (this *Service) getRuleDeps(files []string, config wollemi.Config, dir *Dir
 			path := filepath.Join("plz-out/gen", dir.Path)
 			gopkg, err := this.golang.ImportDir(path, []string{name})
 			if err != nil {
-				return nil, nil, fmt.Errorf("could not parse src file: %s", name)
+				continue
 			}
-
 			fileImports, _ = gopkg.GoFileImports[name]
 		}
 
@@ -433,7 +521,7 @@ func (this *Service) getRuleDeps(files []string, config wollemi.Config, dir *Dir
 		}
 
 		for _, path := range imports {
-			if this.goFormat.isGoroot[path] {
+			if this.goFormat.IsGoRoot(path, this.golang.IsGoroot) {
 				continue
 			}
 
@@ -478,7 +566,6 @@ func (this *Service) getRuleSrcs(dir *Directory, config wollemi.Config, srcFiles
 
 	for _, name := range srcFiles {
 		relpath := filepath.Join(dir.Path, name)
-
 		targetPath := this.getTarget(config, relpath, true)
 		if targetPath == "" {
 			info, ok := dir.Files[name]
@@ -526,7 +613,7 @@ func (this *Service) formatDir(log logging.Logger, dir *Directory) {
 			managed = append(managed, rule)
 		}
 
-		consumer.Update(rule)
+		consumer.Update(this, rule)
 	})
 
 	sortManagedRules(config, managed)
@@ -632,7 +719,7 @@ ManageRules:
 				log.WithField("reason", "no source files").Warn("removed")
 
 				rule.DelAttr("srcs")
-				consumer.Update(rule)
+				consumer.Update(this, rule)
 
 				dir.Build.DelRule(rule.Name())
 
@@ -728,7 +815,7 @@ ManageRules:
 
 			log.Debug("managed")
 
-			consumer.Update(rule)
+			consumer.Update(this, rule)
 		}
 
 		break
@@ -890,7 +977,7 @@ CreateRules:
 			rule.SetAttr("deps", please.Strings(resolved...))
 		}
 
-		consumer.Update(rule)
+		consumer.Update(this, rule)
 
 		dir.Build.SetRule(rule)
 
@@ -917,7 +1004,7 @@ CreateRules:
 	}
 }
 
-func getSrcFilesFromExpr(expr please.Expr, dir *Directory) []string {
+func (this *Service) getSrcFilesFromExpr(expr please.Expr, dir *Directory) []string {
 	var srcFiles []string
 
 	switch expr := expr.(type) {
@@ -927,11 +1014,10 @@ func getSrcFilesFromExpr(expr please.Expr, dir *Directory) []string {
 			case *please.StringExpr:
 				if strings.HasPrefix(s.Value, ":") || strings.HasPrefix(s.Value, "//") {
 					target := please.Split(s.Value)
-
 					if target.Path == "" || target.Path == dir.Path {
 						rule := dir.Build.GetRule(target.Name)
 						if rule != nil {
-							srcFiles = append(srcFiles, getSrcFilesFromExpr(rule.Unwrap(), dir)...)
+							srcFiles = append(srcFiles, this.getSrcFilesFromExpr(rule.Unwrap(), dir)...)
 						}
 					}
 				} else {
@@ -941,8 +1027,8 @@ func getSrcFilesFromExpr(expr please.Expr, dir *Directory) []string {
 		}
 	case *please.BinaryExpr:
 		if expr.Op == "+" {
-			srcFiles = append(srcFiles, getSrcFilesFromExpr(expr.X, dir)...)
-			srcFiles = append(srcFiles, getSrcFilesFromExpr(expr.Y, dir)...)
+			srcFiles = append(srcFiles, this.getSrcFilesFromExpr(expr.X, dir)...)
+			srcFiles = append(srcFiles, this.getSrcFilesFromExpr(expr.Y, dir)...)
 		}
 	case *please.CallExpr:
 		var kind string
@@ -953,13 +1039,86 @@ func getSrcFilesFromExpr(expr please.Expr, dir *Directory) []string {
 		}
 
 		switch kind {
-		case "genrule":
-			outs := please.Attr(expr, "outs")
-			srcFiles = append(srcFiles, getSrcFilesFromExpr(outs, dir)...)
-		case "go_copy":
+		case "go_proto_template_library":
+			// Build the rule key to look up in the map
+			name := please.AttrString(expr, "name")
+			if name == "" {
+				break
+			}
+
+			// The key format matches what you used in processProtoTemplateLibraries
+			ruleKey := dir.Path + ":" + name
+
+			if genFiles, ok := this.goFormat.ruleToProtoTemplateCodegen[ruleKey]; ok {
+				// Convert absolute paths to relative paths for this directory
+				srcFiles = append(srcFiles, genFiles...)
+			}
+			break
+
+			template := please.AttrString(expr, "template")
+			if template == "" {
+				break
+			}
+			target := please.Split(template)
+			templateName := target.Name
+
+			// Get the srcs which are build targets
+			srcs := please.Attr(expr, "srcs")
+			listExpr, ok := srcs.(*please.ListExpr)
+			if !ok {
+				break
+			}
+			var srcTargets []string
+			for _, item := range listExpr.List {
+				stringExpr, ok := item.(*please.StringExpr)
+				if !ok {
+					continue
+				}
+				srcTargets = append(srcTargets, stringExpr.Value)
+			}
+
+			for _, srcTarget := range srcTargets {
+				protoTarget := please.Split(srcTarget)
+
+				// Resolve the proto rule
+				var protoRule please.Rule
+				if protoTarget.Path == "" || protoTarget.Path == dir.Path {
+					protoRule = dir.Build.GetRule(protoTarget.Name)
+				} else {
+					// Handle cross-directory references if needed
+					if protoDir, ok := this.goFormat.directories[protoTarget.Path]; ok {
+						protoRule = protoDir.Build.GetRule(protoTarget.Name)
+					}
+				}
+				if protoRule == nil {
+					continue
+				}
+				// Get the proto files from the proto rule's srcs
+				protoFiles := protoRule.AttrStrings("srcs")
+
+				for _, protoFile := range protoFiles {
+					if !strings.HasSuffix(protoFile, ".proto") {
+						continue
+					}
+
+					// Convert proto file to generated go file
+					genFile := strings.TrimSuffix(protoFile, ".proto")
+					genFile = genFile + "_" + templateName + ".pb.go"
+					genPath := genFile
+					this.goFormat.protoTemplateCodegen[filepath.Join(dir.Path, genPath)] = struct{}{}
+					srcFiles = append(srcFiles, genPath)
+				}
+			}
+		default:
 			if name := please.AttrString(expr, "name"); name != "" {
-				srcFiles = append(srcFiles, name+".cp.go")
+				if formatting, ok := this.config.Gofmt.CodegenRuleFormatting[kind]; ok {
+					filename := strings.ReplaceAll(formatting, "{{ name }}", name)
+					srcFiles = append(srcFiles, filename)
+				}
 			}
+		case "genrule":
+			outs := please.Attr(expr, "outs")
+			srcFiles = append(srcFiles, this.getSrcFilesFromExpr(outs, dir)...)
 		case "glob":
 			var include []string
 			var exclude []string
@@ -1011,7 +1170,7 @@ func getSrcFilesFromExpr(expr please.Expr, dir *Directory) []string {
 			}
 		case "filegroup":
 			srcs := please.Attr(expr, "srcs")
-			srcFiles = append(srcFiles, getSrcFilesFromExpr(srcs, dir)...)
+			srcFiles = append(srcFiles, this.getSrcFilesFromExpr(srcs, dir)...)
 		}
 	}
 
@@ -1143,17 +1302,19 @@ func (fc *fileConsumer) GetRule(files ...string) please.Rule {
 	return rule
 }
 
-func (fc *fileConsumer) Update(rule please.Rule) {
+func (fc *fileConsumer) Update(service *Service, rule please.Rule) {
 	delete(fc.Files, rule.Name())
-
 	for file, rules := range fc.Rules {
 		fc.Rules[file], _ = deleteStrings(rules, rule.Name())
 	}
+	files := service.getSrcFilesFromExpr(rule.Attr("srcs"), fc.Dir)
 
-	files := getSrcFilesFromExpr(rule.Attr("srcs"), fc.Dir)
 
 	for i := 0; i < len(files); i++ {
 		name := files[i]
+		if _, ok := service.goFormat.protoTemplateCodegen[name]; ok {
+			continue
+		}
 
 		switch {
 		case filepath.Ext(name) != ".go":
@@ -1164,19 +1325,19 @@ func (fc *fileConsumer) Update(rule please.Rule) {
 		// Ignore please rule targets
 		default:
 			if _, ok := fc.Dir.Files[name]; !ok {
-				// This golang source file does not exist so it should be stripped
-				// from this rule's source list.
+				if _, ok := service.goFormat.genfiles[fc.Dir.Path + "/" + name]; !ok {
+					// This golang source file does not exist so it should be stripped
+					// from this rule's source list.
+					if i+1 < len(files) {
+						copy(files[i:], files[i+1:])
+					}
 
-				if i+1 < len(files) {
-					copy(files[i:], files[i+1:])
+					files = files[:len(files)-1]
+					i--
 				}
-
-				files = files[:len(files)-1]
-				i--
 			}
 		}
 	}
-
 	fc.Files[rule.Name()] = files
 
 	for _, file := range files {
diff --git a/ports/wollemi/config.go b/ports/wollemi/config.go
index bce9462..0abd722 100644
--- a/ports/wollemi/config.go
+++ b/ports/wollemi/config.go
@@ -26,6 +26,8 @@ type Gofmt struct {
 	Create  gofmtCreate `json:"create,omitempty"`
 	Manage  gofmtManage `json:"manage,omitempty"`
 	Mapped  gofmtMapped `json:"mapped,omitempty"`
+	CodegenRuleFormatting gofmtCodegenRuleFormatting `json:"codegen_rule_formatting,omitempty"`
+	ImportPathRemapping map[string]string `json:"import_path_remapping"`
 }
 
 func (gofmt *Gofmt) GetRewrite() bool {
@@ -106,6 +108,12 @@ func (this Config) Merge(that Config) Config {
 		merge.ExplicitSources = v
 	}
 
+	if v := that.Gofmt.CodegenRuleFormatting; v != nil {
+		merge.Gofmt.CodegenRuleFormatting = v
+	}
+	if v := that.Gofmt.ImportPathRemapping; v != nil {
+		merge.Gofmt.ImportPathRemapping = v
+	}
 	if v := that.Gofmt.Rewrite; v != nil {
 		merge.Gofmt.Rewrite = v
 	}
@@ -125,6 +133,25 @@ func (this Config) Merge(that Config) Config {
 	return merge
 }
 
+type gofmtCodegenRuleFormatting map[string]string
+func (mapped *gofmtCodegenRuleFormatting) UnmarshalJSON(buf []byte) error {
+	tmp := make(map[string]string)
+	err := json.Unmarshal(buf, &tmp)
+
+	if err != nil {
+		s, unquoteErr := strconv.Unquote(string(buf))
+		if unquoteErr == nil && s == "none" {
+			err = nil
+		}
+	}
+
+	*mapped = map[string]string{}
+	for k, v := range tmp {
+		(*mapped)[k] = v
+	}
+	return err
+}
+
 type gofmtCreate []string
 
 func (list *gofmtCreate) UnmarshalJSON(buf []byte) error {
