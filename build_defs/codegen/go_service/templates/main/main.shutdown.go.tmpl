{{- define "shutdownOpts" -}}
func handleSignals(ctx {{ goImport "context" }}.Context, errChan chan error, gracefulStopFns, stopFns[]func() error) {
	signalChan := make(chan {{ goImport "os" }}.Signal, 2) // One for each category of stops.
	{{ goImport "os/signal" }}.Notify(
  	signalChan,
  	{{ goImport "syscall" }}.SIGTERM,
  	{{ goImport "syscall" }}.SIGINT,
  	{{ goImport "syscall" }}.SIGHUP,
	)

	{{ goImport "log/slog" }}.InfoContext(ctx, "waiting for signal")
	// Wait for first signal
	select {
	case sig := <- signalChan:
		{{ goImport "log/slog" }}.InfoContext(ctx, "received signal #1: initiating graceful shutdown", "signal", sig)
	case err := <- errChan:
		slog.ErrorContext(ctx, "serverErrGroup", "error", err)
	}

	// Set up a channel to know when graceful shutdown is complete
	gracefulDone := make(chan struct{})

	// Start graceful shutdown sequentially in reverse order in a goroutine
	go func() {
		for i := len(gracefulStopFns) - 1; i >= 0; i-- {
			gracefulStopFns[i]()
		}
		close(gracefulDone)
	}()

	// Wait for either graceful shutdown to complete or second signal
	select {
	case <-gracefulDone:
		{{ goImport "log/slog" }}.InfoContext(ctx, "graceful shutdown completed")
	case sig := <-signalChan:
		{{ goImport "log/slog" }}.WarnContext(ctx, "Received signal #2: initiating force shutdown", "signal", sig)
		// Force stop everything immediately sequentially in reverse order
		for i := len(stopFns) - 1; i >= 0; i-- {
			stopFns[i]()
		}
		{{ goImport "log/slog" }}.InfoContext(ctx, "force shutdown completed")
	}
}
{{- end -}}
