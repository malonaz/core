package main

var log = {{ goImport "github.com/malonaz/core/go/logging" }}.NewLogger()

var opts struct {
{{ template "mainOpts" . }}
}

func main() {
{{ goImport "math/rand" }}.Seed({{ goImport "time"}}.Now().UnixNano())
{{ goImport "github.com/malonaz/core/go/flags" }}.MustParse(&opts)
{{ goImport "github.com/malonaz/core/go/prometheus" }}.Serve(opts.Prometheus)
ctx := {{ goImport "context" }}.Background()

ctxWithRole, err := {{ goImport "github.com/malonaz/core/go/authentication" }}.WithRole(ctx, "{{ .name }}")
if err != nil {
log.Panicf("injecting role into context: %v", err)
}
ctxWithRole = {{ goImport "github.com/malonaz/core/go/contexttag" }}.SetOntoContextNoop(ctxWithRole)

var healthChecks []{{ goImport "github.com/malonaz/core/go/health" }}.Check

{{- /* GATHER SERVICE MANIFESTS */ -}}
{{- $serviceManifests := list -}}
{{- range $grpcServer := .grpc.servers -}}
    {{- range $service := $grpcServer.services -}}
        {{- $serviceManifest := parseYaml $service.manifest -}}
        {{- $serviceManifests = append $serviceManifests $serviceManifest -}}
    {{- end -}}
{{- end -}}

{{- /* DEPENDENCIES GRPC*/ -}}
{{- range $serviceManifest := $serviceManifests -}}
    {{- range $dep := $serviceManifest.dependencies -}}
        {{- if eq $dep.type "grpc_client" -}}
            {{- if doOnce "grpc_client_instantiations" -}}{{ "\n\n// Instantiate GRPC Clients\n" -}}{{- end -}}
            {{- if doOnce (printf "grpc_deps_%s" $dep.proto) -}}
                {{ $grpc := parseGRPC $dep.proto }}
                {{ $grpc.Connection }}, {{ $grpc.HealthCheck }} := {{ $grpc.NewConnection }}.Connect()
                defer {{ $grpc.Connection }}.Close()
                {{ $grpc.Client }} := {{ $grpc.NewClient }}
                healthChecks = append(healthChecks, {{ $grpc.HealthCheck }})
            {{- end }}
        {{- end }}
    {{- end }}
{{- end }}

{{- /* DEPENDENCIES POSTGRES*/ -}}
{{- range $serviceManifest := $serviceManifests -}}
    {{- range $dep := $serviceManifest.dependencies -}}
        {{- if eq $dep.type "postgres" -}}
            {{- $dbKey := printf "postgres_db_%s" $dep.name -}}
            {{- if doOnce $dbKey }}
                {{- "\n" }}
                // Instantiate {{ $dep.name }} db client.
	              {{ $dep.name }}PsqlClient := {{ goImport "github.com/malonaz/core/go/postgres" }}.MustNewClient(opts.{{ $dep.name | title }}Postgres)
	              defer {{ $dep.name }}PsqlClient.Close()
                {{ $dep.name }}DBClient := {{ plzGoImport $dep.implementation }}.New({{ $dep.name }}PsqlClient)
                healthChecks = append(healthChecks, {{ $dep.name }}PsqlClient.Ping)
            {{- end }}
        {{- end }}
    {{- end }}
{{- end }}

{{- /* INSTANTIATE IMPLEMENTATIONS*/ -}}
{{- range $serviceManifest := $serviceManifests }}
    {{- $serviceName := $serviceManifest.name | camelcase | untitle}}
    {{- $serviceKey := printf "service_%s" $serviceManifest.implementation }}
    {{- if doOnce $serviceKey }}
        {{ "\n" }}// Instantiate {{ $serviceName }}.
        {{ $serviceName }}, err := {{ plzGoImport $serviceManifest.implementation }}.New(
        opts.{{ $serviceName | title }},
        {{- range $dep := $serviceManifest.dependencies }}
            {{- if eq $dep.type "grpc_client" }}
                {{ $grpc := parseGRPC $dep.proto -}}
                {{ $grpc.Client }},
            {{- else if eq $dep.type "postgres" }}
                {{ $dep.name }}DBClient,
            {{- end }}
        {{- end }}
        )
        if err != nil {
        log.Panicf("instantiating {{ $serviceName }}: %v", err)
        }
        // Start {{ $serviceName }} service.
        {{ $serviceName }}Cleanup, err := {{ $serviceName }}.Start(ctxWithRole)
        if err != nil {
        log.Panicf("starting {{ $serviceName }} service: %v", err)
        }
        defer {{ $serviceName }}Cleanup()
    {{- end }}
{{- end }}

// Setup health check.
healthCheck := {{ goImport "github.com/malonaz/core/go/health" }}.Checks(healthChecks...)
{{ goImport "github.com/malonaz/core/go/health" }}.Serve(opts.Health, healthCheck)


// Instantiate interceptors.
authenticationInterceptor, err := {{ goImport "github.com/malonaz/core/go/authentication" }}.NewInterceptor(opts.Authentication)
if err != nil {
log.Panicf("instantiating authentication interceptor: %v", err)
}

var gracefulStopFns []func()
var stopFns []func()

{{ range $grpcServer := .grpc.servers }}
    // Start {{ $grpcServer.name | camelcase }} gRPC Server
    {
    register := func(server *{{ goImport "github.com/malonaz/core/go/grpc"}}.Server) {
    {{- range $service := $grpcServer.services }}
        {{- $serviceManifest := parseYaml $service.manifest -}}
        {{- $serviceName := $serviceManifest.name | camelcase | untitle}}
        {{ $grpc := parseGRPC $service.proto -}}
        {{ $grpc.Register $serviceName }}
    {{- end }}
    }
	  grpcServer := {{ goImport "github.com/malonaz/core/go/grpc"}}.NewServer(opts.{{ $grpcServer.name | camelcase }}GRPC, opts.Certs, opts.Prometheus, register).WithHealthCheck(healthCheck).
    WithPreUnaryInterceptors({{ goImport "github.com/malonaz/core/go/authentication" }}.UnarySessionInjectorInterceptor(), authenticationInterceptor.Unary()).
    WithPreStreamInterceptors({{ goImport "github.com/malonaz/core/go/authentication" }}.StreamSessionInjectorInterceptor(), authenticationInterceptor.Stream())
    gracefulStopFns = append(gracefulStopFns, grpcServer.GracefulStop)
    stopFns = append(stopFns, grpcServer.Stop)
    go grpcServer.Serve()

    {{- $hasGateway := false -}}
    {{- range $service := $grpcServer.services -}}
        {{- if $service.gateway -}}
            {{- $grpc := parseGRPC $service.proto -}}
            {{- if doOnce $grpcServer.name }}
                {{ $hasGateway = true }}
                // GRPC gateway handlers.
                var registerHandlers =[]{{ goImport "github.com/malonaz/core/go/grpc" }}.RegisterHandler{
            {{- end }}
            {{ $grpc.RegisterHandlerFromEndpoint }},
        {{ end }}
    {{ end }}
    {{- if $hasGateway -}}
        }
        grpcGatewayServer := grpc.NewGateway(opts.{{ $grpcServer.name | camelcase }}GRPCGateway, opts.{{ $grpcServer.name | camelcase }}GRPC, opts.Certs, opts.Prometheus, registerHandlers)
        go grpcGatewayServer.Serve(ctx)
    {{- end }}
    }
{{- end }}

signalChan := make(chan {{ goImport "os" }}.Signal, 2) // One for each category of stops.
{{ goImport "os/signal" }}.Notify(signalChan, {{ goImport "syscall" }}.SIGTERM, {{ goImport "syscall" }}.SIGINT, {{ goImport "syscall" }}.SIGHUP)

// Wait for first signal
sig := <- signalChan
log.Infof("Received signal #1: %v, initiating graceful shutdown", sig)

// Start graceful shutdown in parallel
var wg {{ goImport "sync" }}.WaitGroup
wg.Add(len(gracefulStopFns))
for _, gracefulStopFn := range gracefulStopFns {
    go func(fn func()) {
        defer wg.Done()
        fn()
    }(gracefulStopFn)
}

// Set up a channel to know when graceful shutdown is complete
gracefulDone := make(chan struct{})
go func() {
    wg.Wait()
    close(gracefulDone)
}()

// Wait for either graceful shutdown to complete or second signal
select {
case <-gracefulDone:
    log.Info("Graceful shutdown completed")
case sig := <-signalChan:
    log.Warnf("Received signal #2: %v, forcing immediate shutdown", sig)
    // Force stop everything immediately in parallel but wait for completion
    var wg {{ goImport "sync" }}.WaitGroup
    wg.Add(len(stopFns))
    for _, stopFn := range stopFns {
        go func(fn func()) {
            defer wg.Done()
            fn()
        }(stopFn)
    }
    wg.Wait()
    log.Info("Force shutdown completed")
}
}
