{{- /* ################### TOPLINE VARIABLES ################### */ -}}
{{ $file := .File }}
{{- $generatedFile := .GeneratedFile }}
{{- $modelGpi := .AdditionalGoImportPaths.model -}}

// Code generated by protoc-templates. DO NOT EDIT.
// source: {{ $file.Desc.Path }}
package {{ .PackageName }}

import (
	"context"
	"fmt"
	"strings"

	"github.com/jackc/pgx/v5"
)


// Store is this service's db layer.
type Store struct {
	client *postgres.Client
}

// New returns a new db.
func New(client *postgres.Client) *Store {
	return &Store{client: client}
}

func addToWhereClause(whereClause, newClause string) string {
	if whereClause == "" {
		whereClause = "WHERE (" + newClause + ")"
	} else {
		whereClause += " AND (" + newClause + ")"
	}
	return whereClause
}

{{/* ################### VAR COLUMNS ################### */}}
var (
	{{ range $message := $file.Messages -}}
		{{- $modelOpts := (getExt .Desc "malonaz.codegen.model.v1.model_opts") -}}
		{{- if not $modelOpts.DatabaseName -}}{{ continue }}{{- end }}
		{{ $message.GoIdent.GoName }}PostgresColumns = {{ fqn "github.com/malonaz/core/go/postgres" "GetDBColumns" }}({{ $message.GoIdent.GoName | $modelGpi.Ident | qgi }}{})
	{{- end -}}
)

{{/* ################### TYPE DEFINITIONS ################### */}}
{{ range $message := $file.Messages -}}
	{{- $modelOpts := (getExt .Desc "malonaz.codegen.model.v1.model_opts") -}}
	{{- if not $modelOpts.DatabaseName -}}{{ continue }}{{- end }}
	{{- $pr := parseResourceFromMessage $message }}

	{{ $goType := $message.GoIdent.GoName }}
	{{ $goName := $goType | untitle }}
	{{ $goTypeFqi := $message.GoIdent.GoName | $modelGpi.Ident | qgi }}
	{{ $errNotExistFqi := (printf "Err%sNotExist" $goType) | $modelGpi.Ident | qgi }}
	{{ $errAlreadyExistsFqi := (printf "Err%sAlreadyExists" $goType) | $modelGpi.Ident | qgi }}
	{{ $tableName := ternary $pr.Desc.Singular $modelOpts.TableName (empty $modelOpts.TableName) }}
	{{- $placeholders := list }}
	{{- range $i, $var := $pr.PatternVariables }}
		{{ if and (eq $i 0) $modelOpts.IdColumnName }}
			{{- $placeholders = append $placeholders (printf "id = $%d" (add $i 1)) }}
		{{ else }}
			{{- $placeholders = append $placeholders (printf "%s_id = $%d" $var (add $i 1)) }}
		{{ end }}
	{{- end }}
	{{- $placeholderDeclarations := (join " AND " $placeholders) }}
	{{- $columnNames := $pr.PatternVariableIDs false }}
	{{- $identifier := "" }}
	{{- if not $pr.Singleton }} {{ $identifier = printf "%s_id" $pr.PatternVariable }}{{ end }}
	{{ if $modelOpts.IdColumnName }}
		{{ $identifier = $modelOpts.IdColumnName }}
		{{ $columnNames = $columnNames | replace (printf "%s_id" $pr.PatternVariable) $modelOpts.IdColumnName }}
	{{ end }}

	{{/* ################### INSERT ################### */}}
	{{- if not $modelOpts.SkipInsertFunction -}}
		{{- $singletonChildren := list }}
		{{- range $childPr := $pr.Children }}
			{{- if $childPr.Singleton }}
				{{- $childMessage := getMessageUsingResourceType $childPr.Desc.Type }}
				{{- $modelOpts := (getExt $childMessage.Desc "malonaz.codegen.model.v1.model_opts") }}
				{{- if $modelOpts.DatabaseName }}
					{{- $singletonChildren = append $singletonChildren $childPr }}
				{{ end }}
			{{- end }}
		{{- end }}

		{{- if $pr.Singleton }}
			const {{ $message.GoIdent.GoName }}InsertPostgresQuery = `INSERT INTO {{ $tableName }} %s VALUES %s ON CONFLICT({{ $columnNames }}) DO NOTHING`
		{{ else }}
			var {{ $message.GoIdent.GoName | untitle }}InsertPostgresQuery = `INSERT INTO {{ $tableName }} %s VALUES %s ON CONFLICT({{ $columnNames }}) ` +
				postgres.SelectQuery("DO UPDATE SET {{ $identifier }} = EXCLUDED.{{ $identifier }} RETURNING %s", {{ $goType }}PostgresColumns)

			func (s *Store) Insert{{ $message.GoIdent.GoName }}(ctx context.Context, {{ $goName }} *{{ $goTypeFqi }}{{ range $childPr := $singletonChildren }}, {{ $childPr.Desc.Singular | camelcase | untitle }} *{{ $childPr.Desc.Singular | camelcase | $modelGpi.Ident | qgi }}{{ end }}) (*{{ $goTypeFqi }}, error) {
				query, params := postgres.InsertQuery({{ $message.GoIdent.GoName | untitle }}InsertPostgresQuery, {{ $goName }})
				{{ range $i, $childPr := $singletonChildren }}
					{{- $message := getMessageUsingResourceType $childPr.Desc.Type }}
					{{- $modelOpts := (getExt $message.Desc "malonaz.codegen.model.v1.model_opts") }}
					{{ $tableName := ternary $childPr.Desc.Singular $modelOpts.TableName (empty $modelOpts.TableName) }}
					query{{ add $i 2 }}, params{{ add $i 2 }} := postgres.InsertQuery({{ $childPr.Desc.Singular | camelcase }}InsertPostgresQuery, {{ $childPr.Desc.Singular | camelcase | untitle }})
				{{ end }}

				{{ if eq (len $singletonChildren) 0 }}
					rows, err := s.client.Query(ctx, query, params...)
					if err != nil {
						return nil, err
					}
					row, err := pgx.CollectOneRow(rows, pgx.RowToAddrOfStructByNameLax[{{ $goTypeFqi }}])
					if err != nil {
						return nil, err
					}
					return row, nil
				{{ else }}
					// Execute within transaction if jobs are provided (or singleton).
					var inserted *{{ $goTypeFqi }}
					transactionFN := func(tx postgres.Tx) error {
						inserted = nil
						rows, err := tx.Query(ctx, query, params...)
						if err != nil {
							return err
						}
						inserted, err = pgx.CollectOneRow(rows, pgx.RowToAddrOfStructByNameLax[{{ $goTypeFqi }}])
						if err != nil {
							return err
						}

						{{ range $i, $_ := $singletonChildren }}
							if _, err := tx.Exec(ctx, query{{ add $i 2 }}, params{{ add $i 2 }}...); err != nil {
								return err
							}
						{{ end }}
						return nil
					}

					if err := s.client.ExecuteTransaction(ctx, postgres.ReadCommitted, transactionFN); err != nil {
						return nil, err
					}
					return inserted, nil
				{{ end }}
			}


			type {{ $message.GoIdent.GoName }}WithRequestID struct {
				RequestID string `db:"request_id"`
				*{{ $goTypeFqi }}
			}

			func (s *Store) Insert{{ $message.GoIdent.GoName }}Idempotently(ctx context.Context, requestID string, raw{{ $goName }} *{{ $goTypeFqi }}{{ range $childPr := $singletonChildren }}, {{ $childPr.Desc.Singular | camelcase | untitle }} *{{ $childPr.Desc.Singular | camelcase | $modelGpi.Ident | qgi }}{{ end }}) (*{{ $goTypeFqi }}, error) {
        {{ $goName }} := &{{ $message.GoIdent.GoName }}WithRequestID{
        RequestID: requestID,
        {{ $goType }}: raw{{ $goName }},
        }
				query, params := postgres.InsertQuery({{ $message.GoIdent.GoName | untitle }}InsertPostgresQuery, {{ $goName }})
				{{ range $i, $childPr := $singletonChildren }}
					{{- $message := getMessageUsingResourceType $childPr.Desc.Type }}
					{{- $modelOpts := (getExt $message.Desc "malonaz.codegen.model.v1.model_opts") }}
					{{ $tableName := ternary $childPr.Desc.Singular $modelOpts.TableName (empty $modelOpts.TableName) }}
					query{{ add $i 2 }}, params{{ add $i 2 }} := postgres.InsertQuery({{ $childPr.Desc.Singular | camelcase }}InsertPostgresQuery, {{ $childPr.Desc.Singular | camelcase | untitle }})
				{{ end }}

				{{ if eq (len $singletonChildren) 0 }}
					rows, err := s.client.Query(ctx, query, params...)
					if err != nil {
						return nil, err
					}
					row, err := pgx.CollectOneRow(rows, pgx.RowToAddrOfStructByNameLax[{{ $message.GoIdent.GoName }}WithRequestID])
					if err != nil {
						return nil, err
					}
					if row.RequestID != requestID {
						return nil, {{ $errAlreadyExistsFqi }}
					}
					return row.{{ $goType }}, nil
				{{ else }}
					// Execute within transaction if jobs are provided (or singleton).
					var inserted *{{ $goTypeFqi }}
					transactionFN := func(tx postgres.Tx) error {
						inserted = nil
						rows, err := tx.Query(ctx, query, params...)
						if err != nil {
							return err
						}
						row, err := pgx.CollectOneRow(rows, pgx.RowToAddrOfStructByNameLax[{{ $message.GoIdent.GoName }}WithRequestID])
						if err != nil {
							return err
						}
            if row.RequestID != requestID {
						  return {{ $errAlreadyExistsFqi }}
					  }
            inserted = row.{{ $goType }}
						{{ range $i, $_ := $singletonChildren }}
							if _, err := tx.Exec(ctx, query{{ add $i 2 }}, params{{ add $i 2 }}...); err != nil {
								return err
							}
						{{ end }}
						return nil
					}

					if err := s.client.ExecuteTransaction(ctx, postgres.ReadCommitted, transactionFN); err != nil {
						return nil, err
					}
					return inserted, nil
				{{ end }}
			}
		{{- end }}
	{{ end }}


	{{/* ################### UPDATE ################### */}}
	var update{{ $message.GoIdent.GoName }}PostgresQuery = `INSERT INTO {{ $tableName }} %s VALUES %s ON CONFLICT({{ $columnNames }}) ` +
		postgres.SelectQuery("DO UPDATE SET #update_clause# RETURNING %s", {{ $goType }}PostgresColumns)

	func (s *Store) Update{{ $message.GoIdent.GoName }}(ctx context.Context, {{ $goName }} *{{ $goTypeFqi }}, updateClause string) (*{{ $goTypeFqi }}, error) {
		query := strings.Replace(update{{ $message.GoIdent.GoName }}PostgresQuery, "#update_clause#", updateClause, 1)
		query, params := postgres.InsertQuery(query, {{ $goName }})

		rows, err := s.client.Query(ctx, query, params...)
		if err != nil {
			return nil, err
		}
		row, err := pgx.CollectOneRow(rows, pgx.RowToAddrOfStructByNameLax[{{ $goTypeFqi }}])
		if err != nil {
			return nil, err
		}
		return row, nil
	}

	{{/* ################### DELETE ################### */}}
	{{- if not $modelOpts.SkipDeleteFunction -}}
		{{- if $message.Desc.Fields.ByName "delete_time" }}
			func (s *Store) SoftDelete{{ $message.GoIdent.GoName }}(ctx context.Context, {{ $pr.PatternVariableIDs true }} string, deleteTime {{ fqn "time" "Time" }}) (*{{ $goTypeFqi }}, error) {
				query := `UPDATE {{ $tableName }} SET delete_time = ${{ add (len $pr.PatternVariables) 1 }} WHERE {{ $placeholderDeclarations }} AND delete_time IS NULL RETURNING %s`
				query = postgres.SelectQuery(query, {{ $goType }}PostgresColumns)
				rows, err := s.client.Query(ctx, query, {{ $pr.PatternVariableIDs true }}, deleteTime)
				if err != nil {
					return nil, fmt.Errorf("soft deleting {{ $goName }}: %w", err)
				}
				row, err := pgx.CollectOneRow(rows, pgx.RowToAddrOfStructByNameLax[{{ $goTypeFqi }}])
				if err != nil {
					if err == pgx.ErrNoRows {
						return nil, {{ $errNotExistFqi }}
					}
					return nil, err
				}
				return row, nil
			}
		{{ else }}
			func (s *Store) Delete{{ $message.GoIdent.GoName }}(ctx context.Context, {{ $pr.PatternVariableIDs true }} string) error {
				query := `DELETE FROM {{ $tableName }} WHERE {{ $placeholderDeclarations }}`
				result, err := s.client.Exec(ctx, query, {{ $pr.PatternVariableIDs true }})
				if err != nil {
					return err
				}
				if result.RowsAffected() == 1 {
					return {{ $errNotExistFqi }}
				}
				return nil
			}
		{{ end }}
	{{ end }}

	{{/* ################### GET ################### */}}
	{{- if not $modelOpts.SkipGetFunction -}}
		func (s *Store) Get{{ $message.GoIdent.GoName }}(ctx context.Context, {{ $pr.PatternVariableIDs true }} string) (*{{ $goTypeFqi }}, error) {
			query := `SELECT %s FROM {{ $tableName }} WHERE {{ $placeholderDeclarations }}`
			query = postgres.SelectQuery(query, {{ $goType }}PostgresColumns)
			rows, err := s.client.Query(ctx, query, {{ $pr.PatternVariableIDs true }})
			if err != nil {
				return nil, fmt.Errorf("getting {{ $goName }}: %w", err)
			}
			row, err := pgx.CollectOneRow(rows, pgx.RowToAddrOfStructByNameLax[{{ $goTypeFqi }}])
			if err != nil {
				if err == pgx.ErrNoRows {
					return nil, {{ $errNotExistFqi }}
				}
				return nil, fmt.Errorf("collecting row: %w", err)
			}
			return row, nil
		}
	{{ end }}

	{{/* ################### LIST ################### */}}
	func (s *Store) List{{ $message.GoIdent.GoName }}s(ctx context.Context, {{ if $pr.Parent }}{{ $pr.Parent.PatternVariableIDs true }} string, {{ end }}{{- if $message.Desc.Fields.ByName "delete_time" }} showDeleted bool, {{- end }} whereClause, orderByClause, paginationClause string, columns []string, params ...any) ([]*{{ $goTypeFqi }}, error) {
		if columns == nil {
			columns = {{ $goType }}PostgresColumns
		}

		{{ if $pr.Parent }}
			{{- range $var := $pr.Parent.PatternVariables -}}
				if {{ $var | camelcase | untitle }}Id != "-" {
					whereClause = addToWhereClause(whereClause, fmt.Sprintf("{{ $var }}_id = $%d", len(params) + 1))
					params = append(params, {{ $var | camelcase | untitle }}Id)
				}
			{{ end }}
		{{ end }}

		{{- if $message.Desc.Fields.ByName "delete_time" }}
			// Add delete_time filter to whereClause if not showing deleted
			if !showDeleted {
				whereClause = addToWhereClause(whereClause, "delete_time IS NULL")
			}
		{{- end }}

		query := strings.ReplaceAll("SELECT %s FROM {{ $tableName }} #where# #orderby# #pagination#", "#where#", whereClause)
		query = strings.ReplaceAll(query, "#orderby#", orderByClause)
		query = strings.ReplaceAll(query, "#pagination#", paginationClause)
		query = postgres.SelectQuery(query, columns)

		var {{ $goName }}s []*{{ $goTypeFqi }}
		transactionFN := func(tx postgres.Tx) error {
			{{ $goName }}s = nil
			rows, err := tx.Query(ctx, query, params...)
			if err != nil {
				if err == pgx.ErrNoRows {
					return nil
				}
				return fmt.Errorf("selecting {{ $goName }}s: %w", err)
			}
			{{ $goName }}s, err = pgx.CollectRows(rows, pgx.RowToAddrOfStructByNameLax[{{ $goTypeFqi }}])
			if err != nil {
				return fmt.Errorf("collecting rows: %w", err)
			}
			return nil
		}
		return {{ $goName }}s, s.client.ExecuteTransaction(ctx, postgres.RepeatableRead, transactionFN)
	}
{{ end -}}
