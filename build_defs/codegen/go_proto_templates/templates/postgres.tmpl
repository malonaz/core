{{- /* ################### TOPLINE VARIABLES ################### */ -}}
{{ $file := .File }}
{{- $generatedFile := .GeneratedFile }}

// Code generated by protoc-templates. DO NOT EDIT.
// source: {{ $file.Desc.Path }}
package {{ $file.GoPackageName }}

import (
	"context"
	"fmt"
	"strings"

	"github.com/jackc/pgx/v5"
)


// PostgresStore is this service's db layer.
type PostgresStore struct {
	client *postgres.Client
}

// New returns a new db.
func New(client *postgres.Client) *PostgresStore {
	return &PostgresStore{client: client}
}

func addToWhereClause(whereClause, newClause string) string {
	if whereClause == "" {
		whereClause = "WHERE (" + newClause + ")"
	} else {
		whereClause += " AND (" + newClause + ")"
	}
	return whereClause
}

{{/* ################### VAR COLUMNS ################### */}}
var (
{{ range $message := $file.Messages -}}
    {{-  $modelOpts := (getExt .Desc "malonaz.codegen.model.v1.model_opts") -}}
    {{- if not $modelOpts.DatabaseName -}}{{ continue }}{{- end }}
		{{ $message.GoIdent.GoName }}ModelPostgresColumns = {{ fqn "github.com/malonaz/core/go/postgres" "GetDBColumns" }}({{ $message.GoIdent.GoName }}{})
{{- end -}}
)

{{/* ################### TYPE DEFINITIONS ################### */}}
{{ range $message := $file.Messages -}}
{{-  $modelOpts := (getExt .Desc "malonaz.codegen.model.v1.model_opts") -}}
{{- if not $modelOpts.DatabaseName -}}{{ continue }}{{- end }}
{{- $pr := parseResourceFromMessage $message }}

{{ $goName := untitle $message.GoIdent.GoName }}
{{ $modelType := printf "%sModel" ($message.GoIdent.GoName)}}
{{ $modelName := $modelType | untitle }}
{{ $tableName := ternary $pr.Desc.Singular $modelOpts.TableName (empty $modelOpts.TableName) }}
{{- $placeholders := list }}
{{- range $i, $var := $pr.PatternVariables }}
  {{ if and (eq $i 0) $modelOpts.IdColumnName }}
    {{- $placeholders = append $placeholders (printf "id = $%d" (add $i 1)) }}
  {{ else }}
    {{- $placeholders = append $placeholders (printf "%s_id = $%d" $var (add $i 1)) }}
  {{ end }}
{{- end }}
{{- $placeholderDeclarations := (join " AND " $placeholders) }}
{{- $columnNames := $pr.PatternVariableIDs false }}
{{- $identifier := "" }}
{{- if not $pr.Singleton }} {{ $identifier = printf "%s_id" $pr.PatternVariable }}{{ end }}
{{ if $modelOpts.IdColumnName }}
  $identifier = $modelOpts.IdColumnName
{{ $columnNames = $columnNames | replace (printf "%s_id" $pr.PatternVariable) $modelOpts.IdColumnName }}
{{ end }}

{{/* ################### INSERT ################### */}}
{{- if not $modelOpts.SkipInsertFunction -}}
{{- $singletonChildren := list }}
{{- range $childPr := $pr.Children }}
{{- if $childPr.Singleton }}
	{{- $childMessage := getMessageUsingResourceType $childPr.Desc.Type }}
	{{- $modelOpts := (getExt $childMessage.Desc "malonaz.codegen.model.v1.model_opts") }}
    {{- if $modelOpts.DatabaseName }}
  {{- $singletonChildren = append $singletonChildren $childPr }}
  {{ end }}
{{- end }}
{{- end }}


{{- if $pr.Singleton }}
const {{ $message.GoIdent.GoName }}InsertPostgresQuery = `INSERT INTO {{ $tableName }} %s VALUES %s ON CONFLICT({{ $columnNames }}) DO NOTHING`
{{ else }}
var {{ $message.GoIdent.GoName | untitle }}InsertPostgresQuery = `INSERT INTO {{ $tableName }} %s VALUES %s ON CONFLICT({{ $columnNames }}) ` +
  postgres.SelectQuery("DO UPDATE SET {{ $identifier }} = EXCLUDED.{{ $identifier }} RETURNING %s", {{ $modelType }}PostgresColumns)

func (s *PostgresStore) Insert{{ $message.GoIdent.GoName }}(ctx context.Context, requestID string, {{ $goName }} *{{ $modelType }}{{ range $childPr := $singletonChildren }}, {{  $childPr.Desc.Singular | camelcase | untitle }} *{{ $childPr.Desc.Singular | camelcase }}Model{{ end }}) (*{{ $modelType }}, error) {
  {{ $goName }}.RequestID = requestID
	query, params := postgres.InsertQuery({{ $message.GoIdent.GoName | untitle }}InsertPostgresQuery, {{ $goName }})
	{{ range $i, $childPr := $singletonChildren }}
	{{- $message := getMessageUsingResourceType $childPr.Desc.Type }}
	{{- $modelOpts := (getExt $message.Desc "malonaz.codegen.model.v1.model_opts") }}
	{{ $tableName := ternary $childPr.Desc.Singular $modelOpts.TableName (empty $modelOpts.TableName) }}
	query{{ add $i 2 }}, params{{ add $i 2 }} := postgres.InsertQuery({{ $childPr.Desc.Singular | camelcase }}InsertPostgresQuery, {{  $childPr.Desc.Singular | camelcase | untitle }})
	{{ end }}

	{{ if eq (len $singletonChildren) 0 }}
		  rows, err := s.client.Query(ctx, query, params...)
		  if err != nil {
			return nil, err
		  }
      row, err := pgx.CollectOneRow(rows, pgx.RowToAddrOfStructByNameLax[{{ $modelType }}])
      if err != nil {
      return nil, err
      }
      if row.RequestID != requestID {
      return nil, Err{{ $modelType }}AlreadyExists
      }
      return row, nil
  {{ else }}
		// Execute within transaction if jobs are provided (or singleton).
	var inserted *{{ $modelType }}
	transactionFN := func(tx postgres.Tx) error {
    inserted = nil
		rows, err := tx.Query(ctx, query, params...)
		if err != nil {
			return err
		}
    inserted, err = pgx.CollectOneRow(rows, pgx.RowToAddrOfStructByNameLax[{{ $modelType }}])
    if err != nil {
      return err
    }

		{{ range $i, $_ := $singletonChildren }}
		if _, err := tx.Exec(ctx, query{{ add $i 2 }}, params{{ add $i 2 }}...); err != nil {
			return err
		}
		{{ end }}
		return nil
	}

	if err := s.client.ExecuteTransaction(ctx, postgres.ReadCommitted, transactionFN); err != nil {
		return nil, err
	}
	return inserted, nil
  {{ end }}
}
{{- end }}
{{ end }}

{{/* ################### UPDATE ################### */}}
var update{{ $message.GoIdent.GoName }}PostgresQuery = `INSERT INTO {{ $tableName }} %s VALUES %s ON CONFLICT({{ $columnNames }}) ` +
  postgres.SelectQuery("DO UPDATE SET #update_clause# RETURNING %s", {{ $modelType }}PostgresColumns)
func (s *PostgresStore) Update{{ $message.GoIdent.GoName }}(ctx context.Context,  {{ $goName }} *{{ $modelType }}, updateClause string) (*{{ $modelType }}, error) {
	query := strings.Replace(update{{ $message.GoIdent.GoName }}PostgresQuery, "#update_clause#", updateClause, 1)
	query, params := postgres.InsertQuery(query, {{ $goName }})

	rows, err := s.client.Query(ctx, query, params...)
	if err != nil {
		return nil, err
	}
  row, err := pgx.CollectOneRow(rows, pgx.RowToAddrOfStructByNameLax[{{ $modelType }}])
  if err != nil {
  return nil, err
  }
  return row, nil
}

{{/* ################### DELETE ################### */}}
{{- if not $modelOpts.SkipDeleteFunction -}}
{{- if $message.Desc.Fields.ByName "delete_time" }}
func (s *PostgresStore) SoftDelete{{ $message.GoIdent.GoName }}(ctx context.Context, {{ $pr.PatternVariableIDs true }} string, deleteTime {{ fqn "time" "Time"  }}) (*{{ $modelType }}, error) {
	query := `UPDATE {{ $tableName }} SET delete_time = ${{ add (len $pr.PatternVariables) 1 }} WHERE {{ $placeholderDeclarations }} AND delete_time IS NULL RETURNING %s`
	query = postgres.SelectQuery(query, {{ $modelType }}PostgresColumns)
	rows, err := s.client.Query(ctx, query, {{ $pr.PatternVariableIDs true }}, deleteTime)
	if err != nil {
		return nil, fmt.Errorf("soft deleting {{ $goName }}: %w", err)
	}
	row, err := pgx.CollectOneRow(rows, pgx.RowToAddrOfStructByNameLax[{{ $modelType }}])
	if err != nil {
		if err == pgx.ErrNoRows {
			return nil, Err{{ $modelType }}NotExist
		}
		return nil, err
	}
	return row, nil
}
{{ else }}
func (s *PostgresStore) Delete{{ $message.GoIdent.GoName }}(ctx context.Context, {{ $pr.PatternVariableIDs true }} string) (bool, error) {
	query := `DELETE FROM {{ $tableName }} WHERE {{ $placeholderDeclarations }}`
	result, err := s.client.Exec(ctx, query, {{ $pr.PatternVariableIDs true }})
	if err != nil {
		return false, err
	}
	return result.RowsAffected() == 1, nil
}
{{ end }}
{{ end }}

{{/* ################### GET ################### */}}
{{- if not $modelOpts.SkipGetFunction -}}
func (s *PostgresStore) Get{{ $message.GoIdent.GoName }}(ctx context.Context, {{ $pr.PatternVariableIDs true }} string) (*{{ $modelType }}, error) {
	query := `SELECT %s FROM {{ $tableName }} WHERE {{ $placeholderDeclarations }}`
	query = postgres.SelectQuery(query, {{ $modelType }}PostgresColumns)
	rows, err  := s.client.Query(ctx, query, {{ $pr.PatternVariableIDs true }})
	if err != nil {
		return nil, fmt.Errorf("getting {{ $goName }}: %w", err)
	}
	row, err := pgx.CollectOneRow(rows, pgx.RowToAddrOfStructByNameLax[{{ $modelType }}])
	if err != nil {
		if err == pgx.ErrNoRows {
			return nil, Err{{ $modelType }}NotExist
		}
		return nil, fmt.Errorf("collecting row: %w", err)
	}
	return row, nil
};
{{ end }}


{{/* ################### LIST ################### */}}
func (s *PostgresStore) List{{ $message.GoIdent.GoName }}s(ctx context.Context, {{ if $pr.Parent }}{{ $pr.Parent.PatternVariableIDs true }} string, {{ end }} {{- if $message.Desc.Fields.ByName "delete_time" }} showDeleted bool, {{- end }} whereClause, orderByClause, paginationClause string, columns []string, params ...any) ([]*{{ $modelType }}, error) {
	if columns == nil {
		columns = {{ $modelType }}PostgresColumns
	}

	{{ if $pr.Parent }}
	{{- range $var := $pr.Parent.PatternVariables -}}
	if {{ $var | camelcase | untitle }}Id != "-"{
		whereClause = addToWhereClause(whereClause, fmt.Sprintf("{{ $var }}_id = $%d", len(params) + 1))
		params = append(params, {{ $var | camelcase | untitle }}Id )
	}
	{{ end }}
	{{ end }}

	{{- if $message.Desc.Fields.ByName "delete_time" }}
	// Add delete_time filter to whereClause if not showing deleted
	if !showDeleted {
		whereClause = addToWhereClause(whereClause, "delete_time IS NULL")
	}
	{{- end }}

	query := strings.ReplaceAll("SELECT %s FROM {{ $tableName }} #where# #orderby# #pagination#", "#where#", whereClause)
	query = strings.ReplaceAll(query, "#orderby#", orderByClause)
	query = strings.ReplaceAll(query, "#pagination#", paginationClause)
	query = postgres.SelectQuery(query, columns)

	var {{ $goName }}s []*{{ $modelType }}
	transactionFN := func(tx postgres.Tx) error {
		{{ $goName }}s = nil
		rows, err := tx.Query(ctx, query, params...)
		if err != nil {
			if err == pgx.ErrNoRows {
				return nil
			}
			return fmt.Errorf("selecting {{ $goName }}s: %w", err)
		}
		{{ $goName }}s, err = pgx.CollectRows(rows, pgx.RowToAddrOfStructByNameLax[{{ $modelType }}])
		if err != nil {
			return fmt.Errorf("collecting rows: %w", err)
		}
		return nil
	}
	return {{ $goName }}s, s.client.ExecuteTransaction(ctx, postgres.RepeatableRead, transactionFN)
}
{{ end -}}
