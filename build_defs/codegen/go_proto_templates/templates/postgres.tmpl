{{- /* ################### TOPLINE VARIABLES ################### */ -}}
{{ $file := .File }}
{{ $skip := true }}
{{ range $message := $file.Messages -}}
	{{- $modelOpts := getModelOpts . -}}
	  {{- if $modelOpts -}}{{ $skip = false }}{{- end }}
{{- end -}}
{{ if $skip }}
{{ skipGeneration }}
{{ else }}
{{ template "postgres_main" . }}
{{ end }}

{{ define "postgres_main" }}
{{ $file := .File }}
{{- $generatedFile := .GeneratedFile }}
{{- $modelGpi := .AdditionalGoImportPaths.model -}}
// Code generated by protoc-templates. DO NOT EDIT.
// source: {{ $file.Desc.Path }}
package {{ .PackageName }}

import (
	"context"
	"fmt"
	"strings"

	"github.com/jackc/pgx/v5"
)

{{ if doOnce "store_def" }}
// Store is this service's db layer.
type Store struct {
	client *{{ fqn "github.com/malonaz/core/go/postgres" "Client" }}
}

// New returns a new db.
func New(client *{{ fqn "github.com/malonaz/core/go/postgres" "Client" }}) *Store {
	return &Store{client: client}
}
{{ end }}

{{/* ################### VAR COLUMNS ################### */}}
var (
	{{ range $message := $file.Messages -}}
		{{- $modelOpts := getModelOpts . -}}
		  {{- if not $modelOpts -}}{{ continue }}{{- end }}
		{{ $message.GoIdent.GoName }}PostgresColumns = {{ fqn "github.com/malonaz/core/go/postgres" "GetDBColumns" }}({{ $message.GoIdent.GoName | $modelGpi.Ident | qgi }}{})
	{{- end -}}
)

{{/* ################### TYPE DEFINITIONS ################### */}}
{{ range $message := $file.Messages -}}
	{{- $modelOpts := getModelOpts . -}}
	{{- if not $modelOpts -}}{{ continue }}{{- end }}
	{{- $pr := parseResourceFromMessage $message }}

	{{ $goType := $message.GoIdent.GoName }}
	{{ $goName := $goType | untitle }}
	{{ $goTypeFqi := $message.GoIdent.GoName | $modelGpi.Ident | qgi }}
	{{ $errNotExistFqi := (printf "Err%sNotExist" $goType) | $modelGpi.Ident | qgi }}
	{{ $errAlreadyExistsFqi := (printf "Err%sAlreadyExists" $goType) | $modelGpi.Ident | qgi }}
  {{ $errAlreadyDeletedFqi := (printf "Err%sAlreadyDeleted" $goType) | $modelGpi.Ident | qgi }}
	{{ $tableName := ternary ($pr.SingularSnakeCase) $modelOpts.TableName (empty $modelOpts.TableName) }}
  {{- $whereConditions := list }}
	{{- $placeholders := list }}
	{{- range $i, $var := $pr.PatternVariables }}
		{{ if and (eq $i 0) $modelOpts.IdColumnName }}
      {{- $whereConditions = append $whereConditions (printf "%s = $%%d" $modelOpts.IdColumnName) }}
			{{- $placeholders = append $placeholders (printf "%s = $%d" $modelOpts.IdColumnName (add $i 1)) }}
		{{ else }}
      {{- $whereConditions = append $whereConditions (printf "%s_id = $%%d" $var) }}
			{{- $placeholders = append $placeholders (printf "%s_id = $%d" $var (add $i 1)) }}
		{{ end }}
	{{- end }}
  {{- $whereClause := join " AND " $whereConditions }}
	{{- $placeholderDeclarations := (join " AND " $placeholders) }}
	{{- $columnNames := $pr.PatternVariableIDs false }}
	{{- $identifier := "" }}
	{{- if not $pr.Singleton }} {{ $identifier = $pr.PatternVariableID false }}{{ end }}
	{{ if $modelOpts.IdColumnName }}
		{{ $identifier = $modelOpts.IdColumnName }}
		{{ $columnNames = $columnNames | replace ($pr.PatternVariableID false) $modelOpts.IdColumnName }}
	{{ end }}
  {{ $etag := $message.Desc.Fields.ByName "etag" }}

{{/* ############################ ETAG GETTER ############################### */}}
{{ if $etag }}
func (s *Store) get{{ $message.GoIdent.GoName }}ETag(ctx context.Context, {{ $pr.PatternVariableIDs true }} string) (string, error) {
  query := `SELECT etag FROM {{ $tableName }} WHERE {{ $placeholderDeclarations }}`
  rows, err := s.client.Query(ctx, query, {{ $pr.PatternVariableIDs true }})
  if err != nil {
    return "", err
  }
  return pgx.CollectOneRow(rows, pgx.RowTo[string])
}
{{ end }}

	{{/* ################### INSERT ################### */}}
		{{- $singletonChildren := list }}
		{{- range $childPr := $pr.Children }}
			{{- if $childPr.Singleton }}
				{{- $childMessage := getMessageUsingResourceType $childPr.Desc.Type }}
				{{- $modelOpts := getModelOpts $childMessage }}
				{{- if $modelOpts }}
					{{- $singletonChildren = append $singletonChildren $childPr }}
				{{ end }}
			{{- end }}
		{{- end }}

		{{- if $pr.Singleton }}
			const {{ $message.GoIdent.GoName }}InsertPostgresQuery = `INSERT INTO {{ $tableName }} %s VALUES %s ON CONFLICT({{ $columnNames }}) DO NOTHING`
		{{ else }}

	  var (
      {{ $message.GoIdent.GoName }}WithRequestIDPostgresColumns = {{ fqn "github.com/malonaz/core/go/postgres" "GetDBColumns" }}({{ $message.GoIdent.GoName }}WithRequestID{})
      _{{ $message.GoIdent.GoName | untitle }}InsertPostgresQuery = `INSERT INTO {{ $tableName }} %s VALUES %s ON CONFLICT({{ $columnNames }}) DO UPDATE SET {{ $identifier }} = EXCLUDED.{{ $identifier }} RETURNING `
		  {{ $message.GoIdent.GoName | untitle }}WithRequestIDInsertPostgresQuery = _{{ $message.GoIdent.GoName | untitle }}InsertPostgresQuery + postgres.SelectQuery("%s", {{ $goType }}WithRequestIDPostgresColumns)
		  {{ $message.GoIdent.GoName | untitle }}InsertPostgresQuery = _{{ $message.GoIdent.GoName | untitle }}InsertPostgresQuery + postgres.SelectQuery("%s", {{ $goType }}PostgresColumns)
    )

			func (s *Store) Insert{{ $message.GoIdent.GoName }}(ctx context.Context, {{ $goName }} *{{ $goTypeFqi }}{{ range $childPr := $singletonChildren }}, {{ $childPr.Desc.Singular | camelcase | untitle }} *{{ $childPr.SingularGoName | $modelGpi.Ident | qgi }}{{ end }}) (*{{ $goTypeFqi }}, error) {
				query, params := postgres.InsertQuery({{ $message.GoIdent.GoName | untitle }}InsertPostgresQuery, {{ $goName }})
				{{ range $i, $childPr := $singletonChildren }}
					{{- $message := getMessageUsingResourceType $childPr.Desc.Type }}
					{{- $modelOpts := getModelOpts $message }}
					{{ $tableName := ternary ($childPr.Desc.Singular | snakecase) $modelOpts.TableName (empty $modelOpts.TableName) }}
					query{{ add $i 2 }}, params{{ add $i 2 }} := postgres.InsertQuery({{ $childPr.SingularGoName }}InsertPostgresQuery, {{ $childPr.Desc.Singular | camelcase | untitle }})
				{{ end }}

				{{ if eq (len $singletonChildren) 0 }}
					rows, err := s.client.Query(ctx, query, params...)
					if err != nil {
						return nil, err
					}
					row, err := pgx.CollectOneRow(rows, pgx.RowToAddrOfStructByNameLax[{{ $goTypeFqi }}])
					if err != nil {
						return nil, err
					}
					return row, nil
				{{ else }}
					// Execute within transaction if jobs are provided (or singleton).
					var inserted *{{ $goTypeFqi }}
					transactionFN := func(tx postgres.Tx) error {
						inserted = nil
						rows, err := tx.Query(ctx, query, params...)
						if err != nil {
							return err
						}
						inserted, err = pgx.CollectOneRow(rows, pgx.RowToAddrOfStructByNameLax[{{ $goTypeFqi }}])
						if err != nil {
							return err
						}

						{{ range $i, $_ := $singletonChildren }}
							if _, err := tx.Exec(ctx, query{{ add $i 2 }}, params{{ add $i 2 }}...); err != nil {
								return err
							}
						{{ end }}
						return nil
					}

					if err := s.client.ExecuteTransaction(ctx, postgres.ReadCommitted, transactionFN); err != nil {
						return nil, err
					}
					return inserted, nil
				{{ end }}
			}


			type {{ $message.GoIdent.GoName }}WithRequestID struct {
				RequestID string `db:"request_id"`
				{{ $goTypeFqi }}
			}

var {{ $message.GoIdent.GoName | untitle }}GetByRequestIDQuery = `SELECT ` + postgres.SelectQuery("%s", {{ $goType }}PostgresColumns) + ` FROM {{ $tableName }} WHERE request_id = $1`

func (s *Store) Insert{{ $message.GoIdent.GoName }}Idempotently(ctx context.Context, requestID string, raw{{ $goName | title }} *{{ $goTypeFqi }}{{ range $childPr := $singletonChildren }}, {{ $childPr.Desc.Singular | camelcase | untitle }} *{{ $childPr.SingularGoName | $modelGpi.Ident | qgi }}{{ end }}) (*{{ $goTypeFqi }}, error) {
    {{ $goName }} := &{{ $message.GoIdent.GoName }}WithRequestID{
        RequestID: requestID,
        {{ $goType }}: *raw{{ $goName | title }},
    }
    query, params := postgres.InsertQuery({{ $message.GoIdent.GoName | untitle }}WithRequestIDInsertPostgresQuery, {{ $goName }})
    {{ range $i, $childPr := $singletonChildren }}
        {{- $message := getMessageUsingResourceType $childPr.Desc.Type }}
        {{- $modelOpts := getModelOpts $message }}
        {{ $tableName := ternary ($childPr.Desc.Singular | snakecase) $modelOpts.TableName (empty $modelOpts.TableName) }}
        query{{ add $i 2 }}, params{{ add $i 2 }} := postgres.InsertQuery({{ $childPr.SingularGoName }}InsertPostgresQuery, {{ $childPr.Desc.Singular | camelcase | untitle }})
    {{ end }}

    var inserted *{{ $goTypeFqi }}
    transactionFN := func(tx postgres.Tx) error {
        inserted = nil

        // Check for existing request_id (idempotent retry)
        rows, err := tx.Query(ctx, {{ $message.GoIdent.GoName | untitle }}GetByRequestIDQuery, requestID)
        if err != nil {
            return err
        }
        existing, err := pgx.CollectOneRow(rows, pgx.RowToAddrOfStructByNameLax[{{ $goTypeFqi }}])
        if err == nil {
            inserted = existing
            return nil
        }
        if err != pgx.ErrNoRows {
            return err
        }

        // Insert new row
        rows, err = tx.Query(ctx, query, params...)
        if err != nil {
            return err
        }
        row, err := pgx.CollectOneRow(rows, pgx.RowToAddrOfStructByNameLax[{{ $message.GoIdent.GoName }}WithRequestID])
        if err != nil {
            return err
        }
        if row.RequestID != requestID {
            return {{ $errAlreadyExistsFqi }}
        }
        inserted = &row.{{ $goType }}

        {{ range $i, $_ := $singletonChildren }}
            if _, err := tx.Exec(ctx, query{{ add $i 2 }}, params{{ add $i 2 }}...); err != nil {
                return err
            }
        {{ end }}
        return nil
    }

    if err := s.client.ExecuteTransaction(ctx, postgres.ReadCommitted, transactionFN); err != nil {
        return nil, err
    }
    return inserted, nil
    }
		{{- end }}


{{/* ################### UPDATE ################### */}}
var update{{ $message.GoIdent.GoName }}PostgresQuery = `UPDATE {{ $tableName }} SET #update_clause# WHERE #where_clause# ` +
  postgres.SelectQuery("RETURNING %s", {{ $goType }}PostgresColumns)

func (s *Store) Update{{ $message.GoIdent.GoName }}(ctx context.Context, {{ $goName }} *{{ $goTypeFqi }}, updateClause string, updateColumns []string{{- if $etag }}, etag string{{ end }}) (*{{ $goTypeFqi }}, error) {
  // Get update params from the object using the provided columns
  updateParams := {{ fqn "github.com/malonaz/core/go/postgres" "GetParams" }}({{ $goName }}, updateColumns...)

  query := strings.Replace(update{{ $message.GoIdent.GoName }}PostgresQuery, "#update_clause#", updateClause, 1)
  // Build WHERE clause with correct placeholders accounting for update params
  numUpdateParams := len(updateParams)
  whereClause := fmt.Sprintf("{{ $whereClause }}", {{- range $i, $_ := $pr.PatternVariables }}numUpdateParams+{{ add $i 1 }},{{ end }})
  query = strings.Replace(query, "#where_clause#", whereClause, 1)

  // Combine params: update params first, then WHERE clause params
  params := append(updateParams,
    {{- range $i, $var := $pr.PatternVariables }}
    {{ $goName }}.{{ $var | camelcase | title }}ID,
    {{- end }}
  )

  {{- if $etag }}
  if etag != "" {
    query = strings.Replace(query, "RETURNING", fmt.Sprintf("AND etag = $%d RETURNING", len(params)+1), 1)
    params = append(params, etag)
  }
  {{- end }}

  rows, err := s.client.Query(ctx, query, params...)
  if err != nil {
    return nil, err
  }
  row, err := pgx.CollectOneRow(rows, pgx.RowToAddrOfStructByNameLax[{{ $goTypeFqi }}])
  if err != nil {
    if err == pgx.ErrNoRows {
      {{- if $etag }}
      if etag != "" {
        currentEtag, getEtagErr := s.get{{ $message.GoIdent.GoName }}ETag(ctx, {{ range $i, $var := $pr.PatternVariables }}{{ if $i }}, {{ end }}{{ $goName }}.{{ $var | camelcase | title }}ID{{ end }})
        switch getEtagErr {
        case nil:
          if currentEtag == etag { // Should never happen.
            return nil, fmt.Errorf("update matched no rows but etag unchanged: expected etag mismatch")
          }
          return nil, {{ (printf "Err%sETagChanged" $goType) | $modelGpi.Ident | qgi }}
        case pgx.ErrNoRows:
         return nil, {{ $errNotExistFqi }} // Confirmed does not exist.
        default:
         return nil, fmt.Errorf("getting etag: %v", getEtagErr)
        }
      }
      {{- end }}
      return nil, {{ $errNotExistFqi }}
    }
    return nil, err
  }
  return row, nil
}

	{{/* ################### DELETE ################### */}}
      {{- if $message.Desc.Fields.ByName "delete_time" }}
      var softDelete{{ $message.GoIdent.GoName }}PostgresQuery = `UPDATE {{ $tableName }} SET delete_time = COALESCE(delete_time, ${{ add (len $pr.PatternVariables) 1 }}){{- if $etag }}, etag = ${{ add (len $pr.PatternVariables) 2 }}{{- end }} WHERE {{ $placeholderDeclarations }} RETURNING (delete_time < ${{ add (len $pr.PatternVariables) 1 }}) AS was_already_deleted, ` +
  postgres.SelectQuery("%s", {{ $goType }}PostgresColumns)

      type softDelete{{ $message.GoIdent.GoName }}Result struct {
        WasAlreadyDeleted bool `db:"was_already_deleted"`
        {{ $goTypeFqi }}
      }

      func (s *Store) SoftDelete{{ $message.GoIdent.GoName }}(ctx context.Context, {{ $pr.PatternVariableIDs true }} string{{- if $etag }}, etag, newEtag string{{ end }}, deleteTime {{ fqn "time" "Time" }}) (*{{ $goTypeFqi }}, error) {
        query := softDelete{{ $message.GoIdent.GoName }}PostgresQuery
        params := []any{ {{ $pr.PatternVariableIDs true }}, deleteTime{{- if $etag }}, newEtag{{ end }}}
        {{- if $etag }}
        if etag != "" {
          query = strings.Replace(query, "RETURNING", fmt.Sprintf("AND etag = $%d RETURNING", len(params)+1), 1)
          params = append(params, etag)
        }
        {{- end }}
        rows, err := s.client.Query(ctx, query, params...)
        if err != nil {
          return nil, fmt.Errorf("soft deleting {{ $goName }}: %w", err)
        }
        row, err := pgx.CollectOneRow(rows, pgx.RowToAddrOfStructByNameLax[softDelete{{ $message.GoIdent.GoName }}Result])
        if err != nil {
          if err == pgx.ErrNoRows {
            {{- if $etag }}
            if etag != "" {
              currentEtag, getEtagErr := s.get{{ $message.GoIdent.GoName }}ETag(ctx, {{ range $i, $var := $pr.PatternVariables }}{{ if $i }}, {{ end }}{{ $var | camelcase | untitle }}Id{{ end }})
              switch getEtagErr {
              case nil:
                if currentEtag == etag {
                  return nil, fmt.Errorf("soft delete matched no rows but etag unchanged: expected etag mismatch")
                }
                return nil, {{ (printf "Err%sETagChanged" $goType) | $modelGpi.Ident | qgi }}
              case pgx.ErrNoRows:
                return nil, {{ $errNotExistFqi }}
              default:
                return nil, fmt.Errorf("getting etag: %v", getEtagErr)
              }
            }
            {{- end }}
            return nil, {{ $errNotExistFqi }}
          }
          return nil, err
        }
        if row.WasAlreadyDeleted {
          return nil, {{ $errAlreadyDeletedFqi }}
        }
        return &row.{{ $goType }}, nil
      }
    {{ else }}
      func (s *Store) Delete{{ $message.GoIdent.GoName }}(ctx context.Context, {{ $pr.PatternVariableIDs true }} string{{- if $etag }}, etag string{{ end }}) error {
        query := `DELETE FROM {{ $tableName }} WHERE {{ $placeholderDeclarations }}`
        params := []any{ {{ $pr.PatternVariableIDs true }} }
        {{- if $etag }}
        if etag != "" {
          query += fmt.Sprintf(" AND etag = $%d", len(params)+1)
          params = append(params, etag)
        }
        {{- end }}
        result, err := s.client.Exec(ctx, query, params...)
        if err != nil {
          return err
        }
        if result.RowsAffected() == 0 {
          {{- if $etag }}
          if etag != "" {
            currentEtag, getEtagErr := s.get{{ $message.GoIdent.GoName }}ETag(ctx, {{ range $i, $var := $pr.PatternVariables }}{{ if $i }}, {{ end }}{{ $var | camelcase | untitle }}Id{{ end }})
            switch getEtagErr {
            case nil:
              if currentEtag == etag {
                return fmt.Errorf("delete matched no rows but etag unchanged: expected etag mismatch")
              }
              return {{ (printf "Err%sETagChanged" $goType) | $modelGpi.Ident | qgi }}
            case pgx.ErrNoRows:
              return {{ $errNotExistFqi }}
            default:
              return fmt.Errorf("getting etag: %v", getEtagErr)
            }
          }
          {{- end }}
          return {{ $errNotExistFqi }}
        }
        return nil
      }
    {{ end }}

	{{/* ################### GET ################### */}}
		func (s *Store) Get{{ $message.GoIdent.GoName }}(ctx context.Context, {{ $pr.PatternVariableIDs true }} string) (*{{ $goTypeFqi }}, error) {
			query := `SELECT %s FROM {{ $tableName }} WHERE {{ $placeholderDeclarations }}`
			query = postgres.SelectQuery(query, {{ $goType }}PostgresColumns)
			rows, err := s.client.Query(ctx, query, {{ $pr.PatternVariableIDs true }})
			if err != nil {
				return nil, fmt.Errorf("getting {{ $goName }}: %w", err)
			}
			row, err := pgx.CollectOneRow(rows, pgx.RowToAddrOfStructByNameLax[{{ $goTypeFqi }}])
			if err != nil {
				if err == pgx.ErrNoRows {
					return nil, {{ $errNotExistFqi }}
				}
				return nil, fmt.Errorf("collecting row: %w", err)
			}
			return row, nil
		}

	{{/* ################### LIST ################### */}}
	func (s *Store) List{{ $pr.PluralGoName }}(ctx context.Context, {{ if $pr.Parent }}{{ $pr.Parent.PatternVariableIDs true }} string, {{ end }}{{- if $message.Desc.Fields.ByName "delete_time" }} showDeleted bool, {{- end }} whereClause, orderByClause, paginationClause string, columns []string, params ...any) ([]*{{ $goTypeFqi }}, error) {
		if columns == nil {
			columns = {{ $goType }}PostgresColumns
		}

		{{ if $pr.Parent }}
			{{- range $var := $pr.Parent.PatternVariables -}}
				if {{ $var | camelcase | untitle }}Id != "-" && {{ $var | camelcase | untitle }}Id != "" {
					whereClause = {{ fqn "github.com/malonaz/core/go/postgres" "AddToWhereClause" }}(whereClause, fmt.Sprintf("{{ $var }}_id = $%d", len(params) + 1))
					params = append(params, {{ $var | camelcase | untitle }}Id)
				}
			{{ end }}
		{{ end }}

		{{- if $message.Desc.Fields.ByName "delete_time" }}
			// Add delete_time filter to whereClause if not showing deleted
			if !showDeleted {
				whereClause = {{ fqn "github.com/malonaz/core/go/postgres" "AddToWhereClause" }}(whereClause, "delete_time IS NULL")
			}
		{{- end }}

		query := strings.ReplaceAll("SELECT %s FROM {{ $tableName }} #where# #orderby# #pagination#", "#where#", whereClause)
		query = strings.ReplaceAll(query, "#orderby#", orderByClause)
		query = strings.ReplaceAll(query, "#pagination#", paginationClause)
		query = postgres.SelectQuery(query, columns)

		var {{ $pr.PluralGoName | untitle }} []*{{ $goTypeFqi }}
		transactionFN := func(tx postgres.Tx) error {
			{{ $pr.PluralGoName | untitle }} = nil
			rows, err := tx.Query(ctx, query, params...)
			if err != nil {
				if err == pgx.ErrNoRows {
					return nil
				}
				return fmt.Errorf("selecting {{ $pr.PluralGoName | untitle }}: %w", err)
			}
			{{ $pr.PluralGoName | untitle }}, err = pgx.CollectRows(rows, pgx.RowToAddrOfStructByNameLax[{{ $goTypeFqi }}])
			if err != nil {
				return fmt.Errorf("collecting rows: %w", err)
			}
			return nil
		}
		return {{ $pr.PluralGoName | untitle }}, s.client.ExecuteTransaction(ctx, postgres.RepeatableRead, transactionFN)
	}
{{ end -}}
{{ end }}
