{{- /* ################### TOPLINE VARIABLES ################### */ -}}
{{ $file := .File }}
{{- $generatedFile := .GeneratedFile }}
{{- $goImportPath := $file.GoImportPath | toString | replace "\"" "" }}
{{- if $file.Desc.Options.GetGoPackage -}}{{- $goImportPath = printf "%s/db" $file.Desc.Options.GetGoPackage }}{{- end -}}
{{- $modelImportPath := $goImportPath | replace "db" "model" }}

// Code generated by protoc-templates. DO NOT EDIT.
// source: {{ $file.Desc.Path }}
package db

import (
	"context"
	"fmt"
	"strings"

	"github.com/jackc/pgx/v5"
	{{ $_ := fqn $modelImportPath "" }}
	"github.com/malonaz/core/go/postgres"
)


// DB is this service's db layer.
type DB struct {
	client *postgres.Client
}

// New returns a new db.
func New(client *postgres.Client) *DB {
	return &DB{client: client}
}

func addToWhereClause(whereClause, newClause string) string {
	if whereClause == "" {
		whereClause = "WHERE (" + newClause + ")"
	} else {
		whereClause += " AND (" + newClause + ")"
	}
	return whereClause
}

{{/* ################### TYPE DEFINITIONS ################### */}}
{{ "" }}
{{ range $message := $file.Messages -}}
{{-  $modelOpts := (getExt .Desc "malonaz.core.codegen.model.v1.model_opts") -}}
{{- if not $modelOpts.DatabaseName -}}{{ continue }}{{- end }}
{{- $pr := parseResourceFromMessage $message }}

{{ $goName := untitle $message.GoIdent.GoName }}
{{ $tableName := ternary $pr.Desc.Singular $modelOpts.TableName (empty $modelOpts.TableName) }}
{{- $placeholders := list }}
{{- range $i, $var := $pr.PatternVariables }}
  {{ if and (eq $i 0) $modelOpts.IdColumnName }}
    {{- $placeholders = append $placeholders (printf "id = $%d" (add $i 1)) }}
  {{ else }}
    {{- $placeholders = append $placeholders (printf "%s_id = $%d" $var (add $i 1)) }}
  {{ end }}
{{- end }}
{{- $placeholderDeclarations := (join " AND " $placeholders) }}
{{- $columnNames := $pr.PatternVariableIDs false }}
{{ if $modelOpts.IdColumnName }}
{{ $columnNames = $columnNames | replace (printf "%s_" (index $pr.PatternVariables 0 )) "" }}
{{ end }}

{{/* ################### INSERT ################### */}}
{{- if not $modelOpts.SkipInsertFunction -}}
{{- $singletonChildren := list }}
{{- range $childPr := $pr.Children }}
{{- if $childPr.Singleton }}
	{{- $childMessage := getMessageUsingResourceType $childPr.Desc.Type }}
	{{- $modelOpts := (getExt $childMessage.Desc "malonaz.core.codegen.model.v1.model_opts") }}
    {{- if $modelOpts.DatabaseName }}
  {{- $singletonChildren = append $singletonChildren $childPr }}
  {{ end }}
{{- end }}
{{- end }}

const {{ $message.GoIdent.GoName }}InsertQuery = `INSERT INTO {{ $tableName }} %s VALUES %s ON CONFLICT({{ $columnNames }}) DO NOTHING`
func (db *DB) Insert{{ $message.GoIdent.GoName }}(ctx context.Context,  {{ $goName }} *model.{{ $message.GoIdent.GoName }}{{ range $childPr := $singletonChildren }}, {{  $childPr.Desc.Singular | camelcase | untitle }} *model.{{ $childPr.Desc.Singular | camelcase }}{{ end }}) (bool, error) {
	query, params := postgres.InsertQuery({{ $message.GoIdent.GoName }}InsertQuery, {{ $goName }})
	{{ range $i, $childPr := $singletonChildren }}
	{{- $message := getMessageUsingResourceType $childPr.Desc.Type }}
	{{- $modelOpts := (getExt $message.Desc "malonaz.core.codegen.model.v1.model_opts") }}
	{{ $tableName := ternary $childPr.Desc.Singular $modelOpts.TableName (empty $modelOpts.TableName) }}
	query{{ add $i 2 }}, params{{ add $i 2 }} := postgres.InsertQuery({{ $childPr.Desc.Singular | camelcase }}InsertQuery, {{  $childPr.Desc.Singular | camelcase | untitle }})
	{{ end }}

	{{ if eq (len $singletonChildren) 0 }}
		  result, err := db.client.Exec(ctx, query, params...)
		  if err != nil {
			return false, err
		  }
		  return result.RowsAffected() == 1, nil
	{{ end }}

	// Execute within transaction if jobs are provided (or singleton).
	var inserted bool
	transactionFN := func(tx postgres.Tx) error {
		result, err := tx.Exec(ctx, query, params...)
		if err != nil {
			return err
		}
		inserted = result.RowsAffected() == 1

		{{ range $i, $_ := $singletonChildren }}
		if _, err := tx.Exec(ctx, query{{ add $i 2 }}, params{{ add $i 2 }}...); err != nil {
			return err
		}
		{{ end }}
		return nil
	}

	if err := db.client.ExecuteTransaction(ctx, postgres.ReadCommitted, transactionFN); err != nil {
		return false, err
	}
	return inserted, nil
}
{{- end }}

{{/* ################### UPDATE ################### */}}
const Update{{ $message.GoIdent.GoName }}Query = `INSERT INTO {{ $tableName }} %s VALUES %s ON CONFLICT({{ $columnNames }}) DO UPDATE SET #update_clause#`
func (db *DB) Update{{ $message.GoIdent.GoName }}(ctx context.Context,  {{ $goName }} *model.{{ $message.GoIdent.GoName }}, updateClause string) (bool, error) {
	query := strings.ReplaceAll(Update{{ $message.GoIdent.GoName }}Query, "#update_clause#", updateClause)
	query, params := postgres.InsertQuery(query, {{ $goName }})

	result, err := db.client.Exec(ctx, query, params...)
	if err != nil {
		return false, err
	}
	return result.RowsAffected() == 1, nil
}

{{/* ################### DELETE ################### */}}
{{- if not $modelOpts.SkipDeleteFunction -}}
{{- if $message.Desc.Fields.ByName "delete_time" }}
func (db *DB) SoftDelete{{ $message.GoIdent.GoName }}(ctx context.Context, {{ $pr.PatternVariableIDs true }} string, deleteTime {{ fqn "time" "Time"  }}) (*model.{{ $message.GoIdent.GoName }}, bool, error) {
	query := `UPDATE {{ $tableName }} SET delete_time = ${{ add (len $pr.PatternVariables) 1 }} WHERE {{ $placeholderDeclarations }} AND delete_time IS NULL RETURNING %s`
	query = postgres.SelectQuery(query, model.{{ $message.GoIdent.GoName }}Columns)
	rows, err := db.client.Query(ctx, query, {{ $pr.PatternVariableIDs true }}, deleteTime)
	if err != nil {
		return nil, false, fmt.Errorf("soft deleting {{ $goName }}: %w", err)
	}
	row, err := pgx.CollectOneRow(rows, pgx.RowToAddrOfStructByNameLax[model.{{ $message.GoIdent.GoName }}])
	if err != nil {
		if err == pgx.ErrNoRows {
			return nil, false, nil
		}
		return nil, false, fmt.Errorf("collecting row: %w", err)
	}
	return row, true, nil
}
{{ else }}
func (db *DB) Delete{{ $message.GoIdent.GoName }}(ctx context.Context, {{ $pr.PatternVariableIDs true }} string) (bool, error) {
	query := `DELETE FROM {{ $tableName }} WHERE {{ $placeholderDeclarations }}`
	result, err := db.client.Exec(ctx, query, {{ $pr.PatternVariableIDs true }})
	if err != nil {
		return false, err
	}
	return result.RowsAffected() == 1, nil
}
{{ end }}
{{ end }}

{{/* ################### GET ################### */}}
{{- if not $modelOpts.SkipGetFunction -}}
func (db *DB) Get{{ $message.GoIdent.GoName }}(ctx context.Context, {{ $pr.PatternVariableIDs true }} string) (*model.{{ $message.GoIdent.GoName }}, bool, error) {
	query := `SELECT %s FROM {{ $tableName }} WHERE {{ $placeholderDeclarations }}`
	query = postgres.SelectQuery(query, model.{{ $message.GoIdent.GoName }}Columns)
	rows, err  := db.client.Query(ctx, query, {{ $pr.PatternVariableIDs true }})
	if err != nil {
		return nil, false, fmt.Errorf("getting {{ $goName }}: %w", err)
	}
	row, err := pgx.CollectOneRow(rows, pgx.RowToAddrOfStructByNameLax[model.{{ $message.GoIdent.GoName }}])
	if err != nil {
		if err == pgx.ErrNoRows {
			return nil, false, nil
		}
		return nil, false, fmt.Errorf("collecting row: %w", err)
	}

	return row, true, nil
};
{{ end }}


{{/* ################### LIST ################### */}}
func (db *DB) List{{ $message.GoIdent.GoName }}s(ctx context.Context, {{ if $pr.Parent }}{{ $pr.Parent.PatternVariableIDs true }} string, {{ end }} {{- if $message.Desc.Fields.ByName "delete_time" }} showDeleted bool, {{- end }} whereClause, orderByClause, paginationClause string, columns []string, params ...any) ([]*model.{{ $message.GoIdent.GoName }}, error) {
	if columns == nil {
		columns = model.{{ $message.GoIdent.GoName }}Columns
	}

	{{ if $pr.Parent }}
	{{- range $var := $pr.Parent.PatternVariables -}}
	if {{ $var | camelcase | untitle }}Id != "-"{
		whereClause = addToWhereClause(whereClause, fmt.Sprintf("{{ $var }}_id = $%d", len(params) + 1))
		params = append(params, {{ $var | camelcase | untitle }}Id )
	}
	{{ end }}
	{{ end }}

	{{- if $message.Desc.Fields.ByName "delete_time" }}
	// Add delete_time filter to whereClause if not showing deleted
	if !showDeleted {
		whereClause = addToWhereClause(whereClause, "delete_time IS NULL")
	}
	{{- end }}

	query := strings.ReplaceAll("SELECT %s FROM {{ $tableName }} #where# #orderby# #pagination#", "#where#", whereClause)
	query = strings.ReplaceAll(query, "#orderby#", orderByClause)
	query = strings.ReplaceAll(query, "#pagination#", paginationClause)
	query = postgres.SelectQuery(query, columns)

	var {{ $goName }}s []*model.{{ $message.GoIdent.GoName }}
	transactionFN := func(tx postgres.Tx) error {
		{{ $goName }}s = nil
		rows, err := tx.Query(ctx, query, params...)
		if err != nil {
			if err == pgx.ErrNoRows {
				return nil
			}
			return fmt.Errorf("selecting {{ $goName }}s: %w", err)
		}
		{{ $goName }}s, err = pgx.CollectRows(rows, pgx.RowToAddrOfStructByNameLax[model.{{ $message.GoIdent.GoName }}])
		if err != nil {
			return fmt.Errorf("collecting rows: %w", err)
		}
		return nil
	}
	return {{ $goName }}s, db.client.ExecuteTransaction(ctx, postgres.RepeatableRead, transactionFN)
}
{{ end -}}
