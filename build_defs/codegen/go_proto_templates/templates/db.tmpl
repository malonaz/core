{{- /* ################### TOPLINE VARIABLES ################### */ -}}
{{ $file := .File }}
{{ $generatedFile := .GeneratedFile }}
{{- $apiImportPathRaw := $file.GoImportPath | toString | clean | dir -}}
{{- $apiImportPath := printf "%s/%s" (trimPrefix "\"" $apiImportPathRaw) "api" -}}
{{- $dummy := replaceImportPath $file.GoImportPath $apiImportPath -}}
{{- $baseDir := trimPrefix "\"" $apiImportPathRaw }}
{{- $baseDir := dir $baseDir }}
{{- $modelImportPath := printf "%s/%s" $baseDir "model" -}}

// Code generated by protoc-templates. DO NOT EDIT.
// source: {{ $file.GoImportPath }}
package {{ $file.GoPackageName }}

import (
"context"
"fmt"
"strings"

"github.com/jackc/pgx/v5"

"{{ $modelImportPath }}"
"github.com/malonaz/core/go/postgres"
)


// DB is this service's db layer.
type DB struct {
client *postgres.Client
}

// New returns a new db.
func New(client *postgres.Client) *DB {
return &DB{client: client}
}

func addToWhereClause(whereClause, newClause string) string {
if whereClause == "" {
whereClause = "WHERE (" + newClause + ")"
} else {
whereClause += " AND (" + newClause + ")"
}
return whereClause
}

{{/* ################### TYPE DEFINITIONS ################### */}}
{{ "" }}
{{ range $message := $file.Messages -}}
    {{-  $modelOpts := (getExt .Desc "malonaz.core.codegen.model.v1.model_opts") -}}
		{{- if not $modelOpts.DatabaseName -}}{{ continue }}{{- end }}
    {{- $pr := parseResourceFromMessage $message }}

		{{ $goName := untitle $message.GoIdent.GoName }}
		{{ $tableName := ternary $pr.Desc.Singular $modelOpts.TableName (empty $modelOpts.TableName) }}
    {{- $placeholders := list }}
    {{- range $i, $var := $pr.PatternVariables }}
        {{- $placeholders = append $placeholders (printf "%s_id = $%d" $var (add $i 1)) }}
    {{- end }}
    {{- $placeholderDeclarations := (join " AND " $placeholders) }}



		{{/* ################### INSERT ################### */}}
		{{- if not $modelOpts.SkipInsertFunction -}}
        {{- $singletonChildren := list }}
        {{- range $childPr := $pr.Children }}
            {{- if $childPr.Singleton }}
                {{- $singletonChildren = append $singletonChildren $childPr }}
            {{- end }}
        {{- end }}

func (db *DB) Insert{{ $message.GoIdent.GoName }}(ctx context.Context,  {{ $goName }} *model.{{ $message.GoIdent.GoName }}{{ range $childPr := $singletonChildren }}, {{  $childPr.Desc.Singular | camelcase | untitle }} *model.{{ $childPr.Desc.Singular | camelcase }}{{ end }}, opts ...func(context.Context, postgres.Tx) error) (bool, error) {
     query := `INSERT INTO {{ $tableName }} %s VALUES %s ON CONFLICT({{ $pr.PatternVariableIDs false }}) DO NOTHING`
     query, params := postgres.InsertQuery(query, {{ $goName }})
     {{ range $i, $childPr := $singletonChildren }}
        {{- $message := getMessageUsingResourceType $childPr.Desc.Type }}
        {{- $modelOpts := (getExt $message.Desc "malonaz.core.codegen.model.v1.model_opts") }}
    		{{ $tableName := ternary $childPr.Desc.Singular $modelOpts.TableName (empty $modelOpts.TableName) }}
        query{{ add $i 2 }} := `INSERT INTO {{ $tableName }} %s VALUES %s ON CONFLICT({{ $childPr.PatternVariableIDs false }}) DO NOTHING`
       query{{ add $i 2 }}, params{{ add $i 2 }} := postgres.InsertQuery(query{{ add $i 2 }}, {{  $childPr.Desc.Singular | camelcase | untitle }})
     {{ end }}

     {{ if eq (len $singletonChildren) 0 }}
     if len(opts) == 0 {
         result, err := db.client.Exec(ctx, query, params...)
         if err != nil {
             return false, err
         }
         return result.RowsAffected() == 1, nil
     }
     {{ end }}

     // Execute within transaction if opts provided
     var inserted bool
     transactionFN := func(tx postgres.Tx) error {
         result, err := tx.Exec(ctx, query, params...)
         if err != nil {
             return err
         }
         inserted = result.RowsAffected() == 1

         {{ range $i, $_ := $singletonChildren }}
         if _, err := tx.Exec(ctx, query{{ add $i 2 }}, params{{ add $i 2 }}...); err != nil {
             return err
         }
         {{ end }}

         // Apply all opts functions after insertion
         for _, opt := range opts {
             if err := opt(ctx, tx); err != nil {
                 return err
             }
         }
         return nil
     }

     if err := db.client.ExecuteTransaction(ctx, postgres.ReadCommitted, transactionFN); err != nil {
         return false, err
     }
     return inserted, nil
}
{{- end }}

		{{/* ################### UPDATE ################### */}}
func (db *DB) Update{{ $message.GoIdent.GoName }}(ctx context.Context,  {{ $goName }} *model.{{ $message.GoIdent.GoName }}, updateClause string, opts ...func(context.Context, postgres.Tx) error) (bool, error) {
     query := `INSERT INTO {{ $tableName }} %s VALUES %s ON CONFLICT({{ $pr.PatternVariableIDs false }}) DO UPDATE SET #update_clause#`
     query = strings.ReplaceAll(query, "#update_clause#", updateClause)
     query, params := postgres.InsertQuery(query, {{ $goName }})

     if len(opts) == 0 {
         result, err := db.client.Exec(ctx, query, params...)
         if err != nil {
             return false, err
         }
         return result.RowsAffected() == 1, nil
     }

     // Execute within transaction if opts provided
     var updated bool
     transactionFN := func(tx postgres.Tx) error {
         result, err := tx.Exec(ctx, query, params...)
         if err != nil {
             return err
         }
         updated = result.RowsAffected() == 1

         // Apply all opts functions after update
         for _, opt := range opts {
             if err := opt(ctx, tx); err != nil {
                 return err
             }
         }
         return nil
     }

     if err := db.client.ExecuteTransaction(ctx, postgres.ReadCommitted, transactionFN); err != nil {
         return false, err
     }
     return updated, nil
}

{{/* ################### DELETE ################### */}}
{{- if not $modelOpts.SkipDeleteFunction -}}
            {{- if $message.Desc.Fields.ByName "delete_time" }}
func (db *DB) SoftDelete{{ $message.GoIdent.GoName }}(ctx context.Context, {{ $pr.PatternVariableIDs true }} string, deleteTime {{ fqn "time" "Time"  }}) (*model.{{ $message.GoIdent.GoName }}, bool, error) {
     query := `UPDATE {{ $tableName }} SET delete_time = ${{ add (len $pr.PatternVariables) 1 }} WHERE {{ $placeholderDeclarations }} AND delete_time IS NULL RETURNING %s`
     query = postgres.SelectQuery(query, model.{{ $message.GoIdent.GoName }}Columns)
     rows, err := db.client.Query(ctx, query, {{ $pr.PatternVariableIDs true }}, deleteTime)
     if err != nil {
         return nil, false, fmt.Errorf("soft deleting {{ $goName }}: %w", err)
     }
     row, err := pgx.CollectOneRow(rows, pgx.RowToAddrOfStructByNameLax[model.{{ $message.GoIdent.GoName }}])
     if err != nil {
         if err == pgx.ErrNoRows {
             return nil, false, nil
         }
         return nil, false, fmt.Errorf("collecting row: %w", err)
     }
     return row, true, nil
}
{{ else }}
func (db *DB) Delete{{ $message.GoIdent.GoName }}(ctx context.Context, {{ $pr.PatternVariableIDs true }} string) (bool, error) {
     query := `DELETE FROM {{ $tableName }} WHERE {{ $placeholderDeclarations }}`
     result, err := db.client.Exec(ctx, query, {{ $pr.PatternVariableIDs true }})
     if err != nil {
         return false, err
     }
     return result.RowsAffected() == 1, nil
}
{{ end }}
{{ end }}

{{/* ################### GET ################### */}}
{{- if not $modelOpts.SkipGetFunction -}}
func (db *DB) Get{{ $message.GoIdent.GoName }}(ctx context.Context, {{ $pr.PatternVariableIDs true }} string) (*model.{{ $message.GoIdent.GoName }}, bool, error) {
     query := `SELECT %s FROM {{ $tableName }} WHERE {{ $placeholderDeclarations }}`
     query = postgres.SelectQuery(query, model.{{ $message.GoIdent.GoName }}Columns)
     rows, err  := db.client.Query(ctx, query, {{ $pr.PatternVariableIDs true }})
     if err != nil {
         return nil, false, fmt.Errorf("getting {{ $goName }}: %w", err)
     }
     row, err := pgx.CollectOneRow(rows, pgx.RowToAddrOfStructByNameLax[model.{{ $message.GoIdent.GoName }}])
     if err != nil {
         if err == pgx.ErrNoRows {
             return nil, false, nil
         }
         return nil, false, fmt.Errorf("collecting row: %w", err)
     }

     return row, true, nil
};
{{ end }}


{{/* ################### LIST ################### */}}
func (db *DB) List{{ $message.GoIdent.GoName }}s(ctx context.Context, {{ if $pr.Parent }}{{ $pr.Parent.PatternVariableIDs true }} string, {{ end }} {{- if $message.Desc.Fields.ByName "delete_time" }} showDeleted bool, {{- end }} whereClause, orderByClause, paginationClause string, columns []string, params ...any) ([]*model.{{ $message.GoIdent.GoName }}, error) {
     if columns == nil {
       columns = model.{{ $message.GoIdent.GoName }}Columns
     }

     {{ if $pr.Parent }}
       {{- range $var := $pr.Parent.PatternVariables -}}
         if {{ $var | camelcase | untitle }}Id != "-"{
         whereClause = addToWhereClause(whereClause, fmt.Sprintf("{{ $var }}_id = $%d", len(params) + 1))
         params = append(params, {{ $var | camelcase | untitle }}Id )
         }
       {{ end }}
     {{ end }}

     {{- if $message.Desc.Fields.ByName "delete_time" }}
     // Add delete_time filter to whereClause if not showing deleted
     if !showDeleted {
         whereClause = addToWhereClause(whereClause, "delete_time IS NULL")
     }
     {{- end }}

     query := strings.ReplaceAll("SELECT %s FROM {{ $tableName }} #where# #orderby# #pagination#", "#where#", whereClause)
     query = strings.ReplaceAll(query, "#orderby#", orderByClause)
     query = strings.ReplaceAll(query, "#pagination#", paginationClause)
     query = postgres.SelectQuery(query, columns)

     var {{ $goName }}s []*model.{{ $message.GoIdent.GoName }}
     transactionFN := func(tx postgres.Tx) error {
       {{ $goName }}s = nil
       rows, err := tx.Query(ctx, query, params...)
       if err != nil {
           if err == pgx.ErrNoRows {
               return nil
           }
           return fmt.Errorf("selecting {{ $goName }}s: %w", err)
       }
       {{ $goName }}s, err = pgx.CollectRows(rows, pgx.RowToAddrOfStructByNameLax[model.{{ $message.GoIdent.GoName }}])
       if err != nil {
           return fmt.Errorf("collecting rows: %w", err)
       }
       return nil
    }
    return {{ $goName }}s, db.client.ExecuteTransaction(ctx, postgres.RepeatableRead, transactionFN)
}
{{ end -}}
