// Code generated by protoc-templates. DO NOT EDIT.
// source: proto/scheduler/scheduler_service/v1/scheduler_service.proto
package service

import (
	context "context"
	v11 "github.com/malonaz/core/genproto/scheduler/scheduler_service/v1"
	v1 "github.com/malonaz/core/genproto/scheduler/v1"
	model "github.com/malonaz/core/genproto/scheduler/v1/model"
	aip "github.com/malonaz/core/go/aip"
	uuid "github.com/malonaz/core/go/uuid"
	resourcename "go.einride.tech/aip/resourcename"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	proto "google.golang.org/protobuf/proto"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

import (
	pb "github.com/malonaz/core/genproto/scheduler/scheduler_service/v1"
)

// CreateJob creates a Job
func (s *Service) CreateJob(ctx context.Context, request *pb.CreateJobRequest) (*v1.Job, error) {
	// STEP 1: Set identifiers.
	jobId := request.JobId
	if jobId == "" {
		jobId = uuid.MustNewV7().String()
	}

	request.Job.Name = resourcename.Sprint("jobs/{job}", jobId)

	// STEP 2: Instantiate timestamps.
	request.Job.CreateTime = timestamppb.Now()

	// STEP 3: Convert the resource to the database representation.
	job, err := model.JobFromPb(request.Job)
	if err != nil {
		return nil, status.Errorf(codes.Internal, "converting job: %v", err)
	}

	// STEP 4: Insert the resource idempotently.
	ok, err := s.schedulerDBClient.InsertJob(ctx, job)
	if err != nil {
		return nil, status.Errorf(codes.Internal, "inserting job: %v", err)
	}
	if !ok {
		getJobRequest := &pb.GetJobRequest{Name: request.Job.Name}
		var err error
		request.Job, err = s.GetJob(ctx, getJobRequest)
		if err != nil {
			return nil, err
		}
	}

	return request.Job, nil
}

var updateJobRequestParser = aip.NewUpdateRequestParser(&pb.UpdateJobRequest{})

func (s *Service) UpdateJob(ctx context.Context, request *pb.UpdateJobRequest) (*v1.Job, error) {
	// STEP 1: Parse request.
	parsedRequest, err := updateJobRequestParser.Parse(request.UpdateMask, request.Job)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "parsing request: %v", err)
	}

	// STEP 2: retrieve existing resource.
	getJobRequest := &pb.GetJobRequest{Name: request.Job.Name}
	existingJob, err := s.GetJob(ctx, getJobRequest)
	if err != nil {
		return nil, err
	}
	updatedJob := proto.Clone(existingJob).(*v1.Job)

	// STEP 3: Patch the existing resource.

	if err := parsedRequest.ApplyFieldMask(updatedJob, request.Job); err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "applying field mask: %v", err)
	}

	// STEP 4: Insert patched resource.
	job, err := model.JobFromPb(updatedJob)
	if err != nil {
		return nil, status.Errorf(codes.Internal, "converting pb.Job to model.Job: %v", err)
	}
	ok, err := s.schedulerDBClient.UpdateJob(ctx, job, parsedRequest.GetSQLUpsertClause())
	if err != nil {
		return nil, status.Errorf(codes.Internal, "inserting job: %v", err)
	}
	if !ok {
		return nil, status.Errorf(codes.NotFound, "job does not exist")
	}

	return updatedJob, nil
}

func (s *Service) DeleteJob(ctx context.Context, request *pb.DeleteJobRequest) (*emptypb.Empty, error) {
	// STEP 1: Parse resource name.
	jobId, err := model.ParseJobName(request.Name)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "parsing name: %v", err)
	}
	// STEP 2: Hard delete the resource.
	ok, err := s.schedulerDBClient.DeleteJob(ctx, jobId)
	if err != nil {
		return nil, status.Errorf(codes.Internal, "deleting job: %v", err)
	}
	if !ok {
		if request.AllowMissing {
			return &emptypb.Empty{}, nil
		}
		return nil, status.Errorf(codes.NotFound, "job not found or already deleted")
	}

	return &emptypb.Empty{}, nil

}

func (s *Service) GetJob(ctx context.Context, request *pb.GetJobRequest) (*v1.Job, error) {
	if resourcename.ContainsWildcard(request.Name) {
		return nil, status.Errorf(codes.InvalidArgument, "cannot use wildcard")
	}

	jobId, err := model.ParseJobName(request.Name)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "parsing name: %v", err)
	}

	// Retrieve from the database.
	dbJob, ok, err := s.schedulerDBClient.GetJob(ctx, jobId)
	if err != nil {
		return nil, status.Errorf(codes.Internal, "listing job: %v", err)
	}
	if !ok {
		return nil, status.Errorf(codes.NotFound, "not found")
	}

	job, err := dbJob.ToPb()
	if err != nil {
		return nil, status.Errorf(codes.Internal, "converting model.Job to pb.Job: %v", err)
	}
	return job, nil
}

var listJobsRequestParser = aip.NewListRequestParser(&pb.ListJobsRequest{})

func (s *Service) ListJobs(ctx context.Context, request *pb.ListJobsRequest) (*v11.ListJobsResponse, error) {

	// Parse request
	parsed, err := listJobsRequestParser.ParseRequest(request)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, err.Error())
	}
	whereClause, whereParams := parsed.GetSQLWhereClause()
	var dbColumns []string

	// Retrieve from the database.
	dbJobs, err := s.schedulerDBClient.ListJobs(ctx, whereClause, parsed.GetSQLOrderByClause(), parsed.GetSQLPaginationClause(), dbColumns, whereParams...)
	if err != nil {
		return nil, status.Errorf(codes.Internal, "listing job: %v", err)
	}
	nextPageToken := parsed.GetNextPageToken(len(dbJobs))
	if nextPageToken != "" {
		dbJobs = dbJobs[:len(dbJobs)-1]
	}

	// Convert back to proto.
	jobs := make([]*v1.Job, 0, len(dbJobs))
	for _, dbJob := range dbJobs {
		job, err := dbJob.ToPb()
		if err != nil {
			return nil, status.Errorf(codes.Internal, "converting model.Job to pb.Job: %v", err)
		}
		jobs = append(jobs, job)
	}

	// Create and return response.
	return &pb.ListJobsResponse{
		Jobs:          jobs,
		NextPageToken: nextPageToken,
	}, nil
}
