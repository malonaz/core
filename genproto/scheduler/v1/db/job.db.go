// Code generated by protoc-templates. DO NOT EDIT.
// source: proto/scheduler/v1/job.proto
package db

import (
	model "github.com/malonaz/core/genproto/scheduler/v1/model"
)

import (
	"context"
	"fmt"
	"strings"

	"github.com/jackc/pgx/v5"

	"github.com/malonaz/core/go/postgres"
)

// DB is this service's db layer.
type DB struct {
	client *postgres.Client
}

// New returns a new db.
func New(client *postgres.Client) *DB {
	return &DB{client: client}
}

func addToWhereClause(whereClause, newClause string) string {
	if whereClause == "" {
		whereClause = "WHERE (" + newClause + ")"
	} else {
		whereClause += " AND (" + newClause + ")"
	}
	return whereClause
}

const JobInsertQuery = `INSERT INTO job %s VALUES %s ON CONFLICT(job_id) DO NOTHING`

func (db *DB) InsertJob(ctx context.Context, job *model.Job, jobs ...*model.Job) (bool, error) {
	query, params := postgres.InsertQuery(JobInsertQuery, job)

	if len(jobs) == 0 {
		result, err := db.client.Exec(ctx, query, params...)
		if err != nil {
			return false, err
		}
		return result.RowsAffected() == 1, nil
	}

	// Execute within transaction if jobs are provided (or singleton).
	var inserted bool
	transactionFN := func(tx postgres.Tx) error {
		result, err := tx.Exec(ctx, query, params...)
		if err != nil {
			return err
		}
		inserted = result.RowsAffected() == 1

		jobQuery, jobParams := postgres.BatchInsertQuery(JobInsertQuery, jobs)
		_, err = tx.Exec(ctx, jobQuery, jobParams...)
		return err
	}

	if err := db.client.ExecuteTransaction(ctx, postgres.ReadCommitted, transactionFN); err != nil {
		return false, err
	}
	return inserted, nil
}

const UpdateJobQuery = `INSERT INTO job %s VALUES %s ON CONFLICT(job_id) DO UPDATE SET #update_clause#`

func (db *DB) UpdateJob(ctx context.Context, job *model.Job, updateClause string, jobs ...*model.Job) (bool, error) {
	query := strings.ReplaceAll(UpdateJobQuery, "#update_clause#", updateClause)
	query, params := postgres.InsertQuery(query, job)

	if len(jobs) == 0 {
		result, err := db.client.Exec(ctx, query, params...)
		if err != nil {
			return false, err
		}
		return result.RowsAffected() == 1, nil
	}

	// Execute within transaction if opts provided
	var updated bool
	transactionFN := func(tx postgres.Tx) error {
		result, err := tx.Exec(ctx, query, params...)
		if err != nil {
			return err
		}
		updated = result.RowsAffected() == 1

		// Apply all opts functions after update
		jobQuery, jobParams := postgres.BatchInsertQuery(JobInsertQuery, jobs)
		_, err = tx.Exec(ctx, jobQuery, jobParams...)
		return err

		return nil
	}

	if err := db.client.ExecuteTransaction(ctx, postgres.ReadCommitted, transactionFN); err != nil {
		return false, err
	}
	return updated, nil
}

func (db *DB) DeleteJob(ctx context.Context, jobId string) (bool, error) {
	query := `DELETE FROM job WHERE job_id = $1`
	result, err := db.client.Exec(ctx, query, jobId)
	if err != nil {
		return false, err
	}
	return result.RowsAffected() == 1, nil
}

func (db *DB) GetJob(ctx context.Context, jobId string) (*model.Job, bool, error) {
	query := `SELECT %s FROM job WHERE job_id = $1`
	query = postgres.SelectQuery(query, model.JobColumns)
	rows, err := db.client.Query(ctx, query, jobId)
	if err != nil {
		return nil, false, fmt.Errorf("getting job: %w", err)
	}
	row, err := pgx.CollectOneRow(rows, pgx.RowToAddrOfStructByNameLax[model.Job])
	if err != nil {
		if err == pgx.ErrNoRows {
			return nil, false, nil
		}
		return nil, false, fmt.Errorf("collecting row: %w", err)
	}

	return row, true, nil
}

func (db *DB) ListJobs(ctx context.Context, whereClause, orderByClause, paginationClause string, columns []string, params ...any) ([]*model.Job, error) {
	if columns == nil {
		columns = model.JobColumns
	}

	query := strings.ReplaceAll("SELECT %s FROM job #where# #orderby# #pagination#", "#where#", whereClause)
	query = strings.ReplaceAll(query, "#orderby#", orderByClause)
	query = strings.ReplaceAll(query, "#pagination#", paginationClause)
	query = postgres.SelectQuery(query, columns)

	var jobs []*model.Job
	transactionFN := func(tx postgres.Tx) error {
		jobs = nil
		rows, err := tx.Query(ctx, query, params...)
		if err != nil {
			if err == pgx.ErrNoRows {
				return nil
			}
			return fmt.Errorf("selecting jobs: %w", err)
		}
		jobs, err = pgx.CollectRows(rows, pgx.RowToAddrOfStructByNameLax[model.Job])
		if err != nil {
			return fmt.Errorf("collecting rows: %w", err)
		}
		return nil
	}
	return jobs, db.client.ExecuteTransaction(ctx, postgres.RepeatableRead, transactionFN)
}
