// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.9
// 	protoc        v6.30.0
// source: proto/authentication.proto

package authentication

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Configuration defines the complete authentication and authorization setup
// for the system, including all roles and service accounts.
type Configuration struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of all roles defined in the system, including their permissions
	// and inheritance relationships.
	Roles []*Role `protobuf:"bytes,1,rep,name=roles,proto3" json:"roles,omitempty"`
	// List of all service accounts configured in the system, each with their
	// assigned roles for programmatic access.
	ServiceAccounts []*ServiceAccount `protobuf:"bytes,2,rep,name=service_accounts,json=serviceAccounts,proto3" json:"service_accounts,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *Configuration) Reset() {
	*x = Configuration{}
	mi := &file_proto_authentication_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Configuration) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Configuration) ProtoMessage() {}

func (x *Configuration) ProtoReflect() protoreflect.Message {
	mi := &file_proto_authentication_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Configuration.ProtoReflect.Descriptor instead.
func (*Configuration) Descriptor() ([]byte, []int) {
	return file_proto_authentication_proto_rawDescGZIP(), []int{0}
}

func (x *Configuration) GetRoles() []*Role {
	if x != nil {
		return x.Roles
	}
	return nil
}

func (x *Configuration) GetServiceAccounts() []*ServiceAccount {
	if x != nil {
		return x.ServiceAccounts
	}
	return nil
}

// ServiceAccount represents a non-human identity used for programmatic access
// to the system, such as API clients, background jobs, or inter-service communication.
type ServiceAccount struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique identifier for this service account.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// List of role IDs assigned to this service account, determining what
	// permissions and access it has within the system.
	RoleIds       []string `protobuf:"bytes,2,rep,name=role_ids,json=roleIds,proto3" json:"role_ids,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ServiceAccount) Reset() {
	*x = ServiceAccount{}
	mi := &file_proto_authentication_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ServiceAccount) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ServiceAccount) ProtoMessage() {}

func (x *ServiceAccount) ProtoReflect() protoreflect.Message {
	mi := &file_proto_authentication_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ServiceAccount.ProtoReflect.Descriptor instead.
func (*ServiceAccount) Descriptor() ([]byte, []int) {
	return file_proto_authentication_proto_rawDescGZIP(), []int{1}
}

func (x *ServiceAccount) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *ServiceAccount) GetRoleIds() []string {
	if x != nil {
		return x.RoleIds
	}
	return nil
}

// Role defines a set of permissions and capabilities that can be assigned to
// users or service accounts. Roles support inheritance for hierarchical permission management.
type Role struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique identifier for this role.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// List of permission strings this role grants. Permissions typically correspond
	// to RPC method names (e.g., "/api.v1.UserService/GetUser").
	Permissions []string `protobuf:"bytes,2,rep,name=permissions,proto3" json:"permissions,omitempty"`
	// Optional list of role IDs from which this role inherits permissions.
	// Enables hierarchical role definitions where a role can include all
	// permissions from parent roles.
	InheritedRoleIds []string `protobuf:"bytes,3,rep,name=inherited_role_ids,json=inheritedRoleIds,proto3" json:"inherited_role_ids,omitempty"`
	// Optional scope or context for this role, enabling organization-specific
	// or domain-specific role definitions (e.g., "org:123" for organization-level roles).
	Scope         string `protobuf:"bytes,4,opt,name=scope,proto3" json:"scope,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Role) Reset() {
	*x = Role{}
	mi := &file_proto_authentication_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Role) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Role) ProtoMessage() {}

func (x *Role) ProtoReflect() protoreflect.Message {
	mi := &file_proto_authentication_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Role.ProtoReflect.Descriptor instead.
func (*Role) Descriptor() ([]byte, []int) {
	return file_proto_authentication_proto_rawDescGZIP(), []int{2}
}

func (x *Role) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Role) GetPermissions() []string {
	if x != nil {
		return x.Permissions
	}
	return nil
}

func (x *Role) GetInheritedRoleIds() []string {
	if x != nil {
		return x.InheritedRoleIds
	}
	return nil
}

func (x *Role) GetScope() string {
	if x != nil {
		return x.Scope
	}
	return ""
}

// Session represents an authenticated session for either a user or service account,
// containing identity information, permissions, and metadata about the session.
type Session struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique identifier for this session instance.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Unix timestamp (seconds since epoch) when this session was created.
	CreateTimestamp int64 `protobuf:"varint,2,opt,name=create_timestamp,json=createTimestamp,proto3" json:"create_timestamp,omitempty"`
	// Unix timestamp (seconds since epoch) when this session expires and
	// is no longer valid for authentication.
	ExpireTimestamp int64 `protobuf:"varint,3,opt,name=expire_timestamp,json=expireTimestamp,proto3" json:"expire_timestamp,omitempty"`
	// User ID if this session belongs to a human user. Empty for service account sessions.
	UserId string `protobuf:"bytes,4,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// Service account ID if this session represents programmatic access.
	// Empty for human user sessions.
	ServiceAccountId string `protobuf:"bytes,5,opt,name=service_account_id,json=serviceAccountId,proto3" json:"service_account_id,omitempty"`
	// Organization ID that this session is scoped to, enabling multi-tenant
	// access control and organization-specific permissions.
	OrganizationId string `protobuf:"bytes,6,opt,name=organization_id,json=organizationId,proto3" json:"organization_id,omitempty"`
	// List of role IDs active in this session, which may include roles assigned
	// directly to the user/service account plus any additional session-specific roles.
	RoleIds []string `protobuf:"bytes,7,rep,name=role_ids,json=roleIds,proto3" json:"role_ids,omitempty"`
	// Additional metadata about the session, including client information
	// and context for logging and auditing purposes.
	Metadata      *SessionMetadata `protobuf:"bytes,8,opt,name=metadata,proto3" json:"metadata,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Session) Reset() {
	*x = Session{}
	mi := &file_proto_authentication_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Session) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Session) ProtoMessage() {}

func (x *Session) ProtoReflect() protoreflect.Message {
	mi := &file_proto_authentication_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Session.ProtoReflect.Descriptor instead.
func (*Session) Descriptor() ([]byte, []int) {
	return file_proto_authentication_proto_rawDescGZIP(), []int{3}
}

func (x *Session) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Session) GetCreateTimestamp() int64 {
	if x != nil {
		return x.CreateTimestamp
	}
	return 0
}

func (x *Session) GetExpireTimestamp() int64 {
	if x != nil {
		return x.ExpireTimestamp
	}
	return 0
}

func (x *Session) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

func (x *Session) GetServiceAccountId() string {
	if x != nil {
		return x.ServiceAccountId
	}
	return ""
}

func (x *Session) GetOrganizationId() string {
	if x != nil {
		return x.OrganizationId
	}
	return ""
}

func (x *Session) GetRoleIds() []string {
	if x != nil {
		return x.RoleIds
	}
	return nil
}

func (x *Session) GetMetadata() *SessionMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

// SessionMetadata contains contextual information about a session, useful for
// logging, auditing, security monitoring, and debugging.
type SessionMetadata struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// IP address of the client that created or is using this session,
	// useful for security monitoring and geographic access tracking.
	IpAddress string `protobuf:"bytes,1,opt,name=ip_address,json=ipAddress,proto3" json:"ip_address,omitempty"`
	// Semantic version of the client application making requests with this session,
	// enabling version-specific behavior and compatibility tracking.
	ClientVersion *ClientVersion `protobuf:"bytes,2,opt,name=client_version,json=clientVersion,proto3" json:"client_version,omitempty"`
	// User-Agent string from the client, providing information about the
	// client software, operating system, and browser (if applicable).
	UserAgent string `protobuf:"bytes,3,opt,name=user_agent,json=userAgent,proto3" json:"user_agent,omitempty"`
	// Extensible key-value store for additional custom metadata that may be
	// needed for specific use cases or integrations.
	KeyToValue    map[string]string `protobuf:"bytes,4,rep,name=key_to_value,json=keyToValue,proto3" json:"key_to_value,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SessionMetadata) Reset() {
	*x = SessionMetadata{}
	mi := &file_proto_authentication_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SessionMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SessionMetadata) ProtoMessage() {}

func (x *SessionMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_proto_authentication_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SessionMetadata.ProtoReflect.Descriptor instead.
func (*SessionMetadata) Descriptor() ([]byte, []int) {
	return file_proto_authentication_proto_rawDescGZIP(), []int{4}
}

func (x *SessionMetadata) GetIpAddress() string {
	if x != nil {
		return x.IpAddress
	}
	return ""
}

func (x *SessionMetadata) GetClientVersion() *ClientVersion {
	if x != nil {
		return x.ClientVersion
	}
	return nil
}

func (x *SessionMetadata) GetUserAgent() string {
	if x != nil {
		return x.UserAgent
	}
	return ""
}

func (x *SessionMetadata) GetKeyToValue() map[string]string {
	if x != nil {
		return x.KeyToValue
	}
	return nil
}

// ClientVersion represents a semantic version (semver) of the client application,
// following the major.minor.patch versioning scheme.
type ClientVersion struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Major version number, incremented for incompatible API changes.
	Major int32 `protobuf:"varint,1,opt,name=major,proto3" json:"major,omitempty"`
	// Minor version number, incremented for backwards-compatible functionality additions.
	Minor int32 `protobuf:"varint,2,opt,name=minor,proto3" json:"minor,omitempty"`
	// Patch version number, incremented for backwards-compatible bug fixes.
	Patch         int32 `protobuf:"varint,3,opt,name=patch,proto3" json:"patch,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClientVersion) Reset() {
	*x = ClientVersion{}
	mi := &file_proto_authentication_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClientVersion) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClientVersion) ProtoMessage() {}

func (x *ClientVersion) ProtoReflect() protoreflect.Message {
	mi := &file_proto_authentication_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClientVersion.ProtoReflect.Descriptor instead.
func (*ClientVersion) Descriptor() ([]byte, []int) {
	return file_proto_authentication_proto_rawDescGZIP(), []int{5}
}

func (x *ClientVersion) GetMajor() int32 {
	if x != nil {
		return x.Major
	}
	return 0
}

func (x *ClientVersion) GetMinor() int32 {
	if x != nil {
		return x.Minor
	}
	return 0
}

func (x *ClientVersion) GetPatch() int32 {
	if x != nil {
		return x.Patch
	}
	return 0
}

var File_proto_authentication_proto protoreflect.FileDescriptor

const file_proto_authentication_proto_rawDesc = "" +
	"\n" +
	"\x1aproto/authentication.proto\x12\x1emalonaz.core.authentication.v1\"\xa6\x01\n" +
	"\rConfiguration\x12:\n" +
	"\x05roles\x18\x01 \x03(\v2$.malonaz.core.authentication.v1.RoleR\x05roles\x12Y\n" +
	"\x10service_accounts\x18\x02 \x03(\v2..malonaz.core.authentication.v1.ServiceAccountR\x0fserviceAccounts\";\n" +
	"\x0eServiceAccount\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x19\n" +
	"\brole_ids\x18\x02 \x03(\tR\aroleIds\"|\n" +
	"\x04Role\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12 \n" +
	"\vpermissions\x18\x02 \x03(\tR\vpermissions\x12,\n" +
	"\x12inherited_role_ids\x18\x03 \x03(\tR\x10inheritedRoleIds\x12\x14\n" +
	"\x05scope\x18\x04 \x01(\tR\x05scope\"\xc7\x02\n" +
	"\aSession\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12)\n" +
	"\x10create_timestamp\x18\x02 \x01(\x03R\x0fcreateTimestamp\x12)\n" +
	"\x10expire_timestamp\x18\x03 \x01(\x03R\x0fexpireTimestamp\x12\x17\n" +
	"\auser_id\x18\x04 \x01(\tR\x06userId\x12,\n" +
	"\x12service_account_id\x18\x05 \x01(\tR\x10serviceAccountId\x12'\n" +
	"\x0forganization_id\x18\x06 \x01(\tR\x0eorganizationId\x12\x19\n" +
	"\brole_ids\x18\a \x03(\tR\aroleIds\x12K\n" +
	"\bmetadata\x18\b \x01(\v2/.malonaz.core.authentication.v1.SessionMetadataR\bmetadata\"\xc7\x02\n" +
	"\x0fSessionMetadata\x12\x1d\n" +
	"\n" +
	"ip_address\x18\x01 \x01(\tR\tipAddress\x12T\n" +
	"\x0eclient_version\x18\x02 \x01(\v2-.malonaz.core.authentication.v1.ClientVersionR\rclientVersion\x12\x1d\n" +
	"\n" +
	"user_agent\x18\x03 \x01(\tR\tuserAgent\x12a\n" +
	"\fkey_to_value\x18\x04 \x03(\v2?.malonaz.core.authentication.v1.SessionMetadata.KeyToValueEntryR\n" +
	"keyToValue\x1a=\n" +
	"\x0fKeyToValueEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"Q\n" +
	"\rClientVersion\x12\x14\n" +
	"\x05major\x18\x01 \x01(\x05R\x05major\x12\x14\n" +
	"\x05minor\x18\x02 \x01(\x05R\x05minor\x12\x14\n" +
	"\x05patch\x18\x03 \x01(\x05R\x05patchB1Z/github.com/malonaz/core/genproto/authenticationb\x06proto3"

var (
	file_proto_authentication_proto_rawDescOnce sync.Once
	file_proto_authentication_proto_rawDescData []byte
)

func file_proto_authentication_proto_rawDescGZIP() []byte {
	file_proto_authentication_proto_rawDescOnce.Do(func() {
		file_proto_authentication_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_proto_authentication_proto_rawDesc), len(file_proto_authentication_proto_rawDesc)))
	})
	return file_proto_authentication_proto_rawDescData
}

var file_proto_authentication_proto_msgTypes = make([]protoimpl.MessageInfo, 7)
var file_proto_authentication_proto_goTypes = []any{
	(*Configuration)(nil),   // 0: malonaz.core.authentication.v1.Configuration
	(*ServiceAccount)(nil),  // 1: malonaz.core.authentication.v1.ServiceAccount
	(*Role)(nil),            // 2: malonaz.core.authentication.v1.Role
	(*Session)(nil),         // 3: malonaz.core.authentication.v1.Session
	(*SessionMetadata)(nil), // 4: malonaz.core.authentication.v1.SessionMetadata
	(*ClientVersion)(nil),   // 5: malonaz.core.authentication.v1.ClientVersion
	nil,                     // 6: malonaz.core.authentication.v1.SessionMetadata.KeyToValueEntry
}
var file_proto_authentication_proto_depIdxs = []int32{
	2, // 0: malonaz.core.authentication.v1.Configuration.roles:type_name -> malonaz.core.authentication.v1.Role
	1, // 1: malonaz.core.authentication.v1.Configuration.service_accounts:type_name -> malonaz.core.authentication.v1.ServiceAccount
	4, // 2: malonaz.core.authentication.v1.Session.metadata:type_name -> malonaz.core.authentication.v1.SessionMetadata
	5, // 3: malonaz.core.authentication.v1.SessionMetadata.client_version:type_name -> malonaz.core.authentication.v1.ClientVersion
	6, // 4: malonaz.core.authentication.v1.SessionMetadata.key_to_value:type_name -> malonaz.core.authentication.v1.SessionMetadata.KeyToValueEntry
	5, // [5:5] is the sub-list for method output_type
	5, // [5:5] is the sub-list for method input_type
	5, // [5:5] is the sub-list for extension type_name
	5, // [5:5] is the sub-list for extension extendee
	0, // [0:5] is the sub-list for field type_name
}

func init() { file_proto_authentication_proto_init() }
func file_proto_authentication_proto_init() {
	if File_proto_authentication_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_proto_authentication_proto_rawDesc), len(file_proto_authentication_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   7,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_proto_authentication_proto_goTypes,
		DependencyIndexes: file_proto_authentication_proto_depIdxs,
		MessageInfos:      file_proto_authentication_proto_msgTypes,
	}.Build()
	File_proto_authentication_proto = out.File
	file_proto_authentication_proto_goTypes = nil
	file_proto_authentication_proto_depIdxs = nil
}
