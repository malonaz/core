// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v6.32.1
// source: malonaz/authentication/v1/authentication.proto

//go:build !protoopaque

package v1

import (
	_ "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Type of the service account.
type ServiceAccountType int32

const (
	// Used to detect an unset field.
	ServiceAccountType_SERVICE_ACCOUNT_TYPE_UNSPECIFIED ServiceAccountType = 0
	// Represents an external system accessing your API via an API key
	ServiceAccountType_SERVICE_ACCOUNT_TYPE_API_KEY ServiceAccountType = 1
	// Represents an internal service within your system architecture
	ServiceAccountType_SERVICE_ACCOUNT_TYPE_INTERNAL_SERVICE ServiceAccountType = 2
)

// Enum value maps for ServiceAccountType.
var (
	ServiceAccountType_name = map[int32]string{
		0: "SERVICE_ACCOUNT_TYPE_UNSPECIFIED",
		1: "SERVICE_ACCOUNT_TYPE_API_KEY",
		2: "SERVICE_ACCOUNT_TYPE_INTERNAL_SERVICE",
	}
	ServiceAccountType_value = map[string]int32{
		"SERVICE_ACCOUNT_TYPE_UNSPECIFIED":      0,
		"SERVICE_ACCOUNT_TYPE_API_KEY":          1,
		"SERVICE_ACCOUNT_TYPE_INTERNAL_SERVICE": 2,
	}
)

func (x ServiceAccountType) Enum() *ServiceAccountType {
	p := new(ServiceAccountType)
	*p = x
	return p
}

func (x ServiceAccountType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ServiceAccountType) Descriptor() protoreflect.EnumDescriptor {
	return file_malonaz_authentication_v1_authentication_proto_enumTypes[0].Descriptor()
}

func (ServiceAccountType) Type() protoreflect.EnumType {
	return &file_malonaz_authentication_v1_authentication_proto_enumTypes[0]
}

func (x ServiceAccountType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Configuration for roles.
type PermissionConfiguration struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// List of all service accounts configured in the system, each with their
	// assigned roles & permissions for programmatic access.
	ServiceAccounts []*ServiceAccount `protobuf:"bytes,1,rep,name=service_accounts,json=serviceAccounts,proto3" json:"service_accounts,omitempty"`
	// List of all roles defined in the system, including their permissions
	// and inheritance relationships.
	Roles []*Role `protobuf:"bytes,2,rep,name=roles,proto3" json:"roles,omitempty"`
	// List of RPC methods that can be accessed without authentication
	// (e.g., "/api.v1.AuthService/Login").
	PublicMethods []string `protobuf:"bytes,3,rep,name=public_methods,json=publicMethods,proto3" json:"public_methods,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PermissionConfiguration) Reset() {
	*x = PermissionConfiguration{}
	mi := &file_malonaz_authentication_v1_authentication_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PermissionConfiguration) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PermissionConfiguration) ProtoMessage() {}

func (x *PermissionConfiguration) ProtoReflect() protoreflect.Message {
	mi := &file_malonaz_authentication_v1_authentication_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *PermissionConfiguration) GetServiceAccounts() []*ServiceAccount {
	if x != nil {
		return x.ServiceAccounts
	}
	return nil
}

func (x *PermissionConfiguration) GetRoles() []*Role {
	if x != nil {
		return x.Roles
	}
	return nil
}

func (x *PermissionConfiguration) GetPublicMethods() []string {
	if x != nil {
		return x.PublicMethods
	}
	return nil
}

func (x *PermissionConfiguration) SetServiceAccounts(v []*ServiceAccount) {
	x.ServiceAccounts = v
}

func (x *PermissionConfiguration) SetRoles(v []*Role) {
	x.Roles = v
}

func (x *PermissionConfiguration) SetPublicMethods(v []string) {
	x.PublicMethods = v
}

type PermissionConfiguration_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// List of all service accounts configured in the system, each with their
	// assigned roles & permissions for programmatic access.
	ServiceAccounts []*ServiceAccount
	// List of all roles defined in the system, including their permissions
	// and inheritance relationships.
	Roles []*Role
	// List of RPC methods that can be accessed without authentication
	// (e.g., "/api.v1.AuthService/Login").
	PublicMethods []string
}

func (b0 PermissionConfiguration_builder) Build() *PermissionConfiguration {
	m0 := &PermissionConfiguration{}
	b, x := &b0, m0
	_, _ = b, x
	x.ServiceAccounts = b.ServiceAccounts
	x.Roles = b.Roles
	x.PublicMethods = b.PublicMethods
	return m0
}

// Configuration for service accounts.
type ServiceAccountConfiguration struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// List of all service accounts configured in the system, each with their
	// assigned roles for programmatic access.
	ServiceAccounts []*ServiceAccount `protobuf:"bytes,1,rep,name=service_accounts,json=serviceAccounts,proto3" json:"service_accounts,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ServiceAccountConfiguration) Reset() {
	*x = ServiceAccountConfiguration{}
	mi := &file_malonaz_authentication_v1_authentication_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ServiceAccountConfiguration) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ServiceAccountConfiguration) ProtoMessage() {}

func (x *ServiceAccountConfiguration) ProtoReflect() protoreflect.Message {
	mi := &file_malonaz_authentication_v1_authentication_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *ServiceAccountConfiguration) GetServiceAccounts() []*ServiceAccount {
	if x != nil {
		return x.ServiceAccounts
	}
	return nil
}

func (x *ServiceAccountConfiguration) SetServiceAccounts(v []*ServiceAccount) {
	x.ServiceAccounts = v
}

type ServiceAccountConfiguration_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// List of all service accounts configured in the system, each with their
	// assigned roles for programmatic access.
	ServiceAccounts []*ServiceAccount
}

func (b0 ServiceAccountConfiguration_builder) Build() *ServiceAccountConfiguration {
	m0 := &ServiceAccountConfiguration{}
	b, x := &b0, m0
	_, _ = b, x
	x.ServiceAccounts = b.ServiceAccounts
	return m0
}

// ServiceAccount represents a non-human identity used for programmatic access
// to the system, such as API clients, background jobs, or inter-service communication.
type ServiceAccount struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Unique identifier for this service account.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The type of sercice account this is.
	Type ServiceAccountType `protobuf:"varint,2,opt,name=type,proto3,enum=malonaz.authentication.v1.ServiceAccountType" json:"type,omitempty"`
	// List of role IDs assigned to this service account, determining what
	// permissions and access it has within the system.
	RoleIds []string `protobuf:"bytes,3,rep,name=role_ids,json=roleIds,proto3" json:"role_ids,omitempty"`
	// Permission this service account has access to.
	Permissions []string `protobuf:"bytes,4,rep,name=permissions,proto3" json:"permissions,omitempty"`
	// The labels on this sessino.
	Labels        map[string]string `protobuf:"bytes,5,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ServiceAccount) Reset() {
	*x = ServiceAccount{}
	mi := &file_malonaz_authentication_v1_authentication_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ServiceAccount) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ServiceAccount) ProtoMessage() {}

func (x *ServiceAccount) ProtoReflect() protoreflect.Message {
	mi := &file_malonaz_authentication_v1_authentication_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *ServiceAccount) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *ServiceAccount) GetType() ServiceAccountType {
	if x != nil {
		return x.Type
	}
	return ServiceAccountType_SERVICE_ACCOUNT_TYPE_UNSPECIFIED
}

func (x *ServiceAccount) GetRoleIds() []string {
	if x != nil {
		return x.RoleIds
	}
	return nil
}

func (x *ServiceAccount) GetPermissions() []string {
	if x != nil {
		return x.Permissions
	}
	return nil
}

func (x *ServiceAccount) GetLabels() map[string]string {
	if x != nil {
		return x.Labels
	}
	return nil
}

func (x *ServiceAccount) SetId(v string) {
	x.Id = v
}

func (x *ServiceAccount) SetType(v ServiceAccountType) {
	x.Type = v
}

func (x *ServiceAccount) SetRoleIds(v []string) {
	x.RoleIds = v
}

func (x *ServiceAccount) SetPermissions(v []string) {
	x.Permissions = v
}

func (x *ServiceAccount) SetLabels(v map[string]string) {
	x.Labels = v
}

type ServiceAccount_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Unique identifier for this service account.
	Id string
	// The type of sercice account this is.
	Type ServiceAccountType
	// List of role IDs assigned to this service account, determining what
	// permissions and access it has within the system.
	RoleIds []string
	// Permission this service account has access to.
	Permissions []string
	// The labels on this sessino.
	Labels map[string]string
}

func (b0 ServiceAccount_builder) Build() *ServiceAccount {
	m0 := &ServiceAccount{}
	b, x := &b0, m0
	_, _ = b, x
	x.Id = b.Id
	x.Type = b.Type
	x.RoleIds = b.RoleIds
	x.Permissions = b.Permissions
	x.Labels = b.Labels
	return m0
}

// Role defines a set of permissions and capabilities that can be assigned to
// users or service accounts. Roles support inheritance for hierarchical permission management.
type Role struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Unique identifier for this role.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// List of permission strings this role grants. Permissions typically correspond
	// to RPC method names (e.g., "/api.v1.UserService/GetUser").
	Permissions []string `protobuf:"bytes,2,rep,name=permissions,proto3" json:"permissions,omitempty"`
	// Optional list of role IDs from which this role inherits permissions.
	// Enables hierarchical role definitions where a role can include all
	// permissions from parent roles.
	InheritedRoleIds []string `protobuf:"bytes,3,rep,name=inherited_role_ids,json=inheritedRoleIds,proto3" json:"inherited_role_ids,omitempty"`
	// Optional scope or context for this role, enabling organization-specific
	// or domain-specific role definitions (e.g., "org:123" for organization-level roles).
	Scope         string `protobuf:"bytes,4,opt,name=scope,proto3" json:"scope,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Role) Reset() {
	*x = Role{}
	mi := &file_malonaz_authentication_v1_authentication_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Role) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Role) ProtoMessage() {}

func (x *Role) ProtoReflect() protoreflect.Message {
	mi := &file_malonaz_authentication_v1_authentication_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *Role) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Role) GetPermissions() []string {
	if x != nil {
		return x.Permissions
	}
	return nil
}

func (x *Role) GetInheritedRoleIds() []string {
	if x != nil {
		return x.InheritedRoleIds
	}
	return nil
}

func (x *Role) GetScope() string {
	if x != nil {
		return x.Scope
	}
	return ""
}

func (x *Role) SetId(v string) {
	x.Id = v
}

func (x *Role) SetPermissions(v []string) {
	x.Permissions = v
}

func (x *Role) SetInheritedRoleIds(v []string) {
	x.InheritedRoleIds = v
}

func (x *Role) SetScope(v string) {
	x.Scope = v
}

type Role_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Unique identifier for this role.
	Id string
	// List of permission strings this role grants. Permissions typically correspond
	// to RPC method names (e.g., "/api.v1.UserService/GetUser").
	Permissions []string
	// Optional list of role IDs from which this role inherits permissions.
	// Enables hierarchical role definitions where a role can include all
	// permissions from parent roles.
	InheritedRoleIds []string
	// Optional scope or context for this role, enabling organization-specific
	// or domain-specific role definitions (e.g., "org:123" for organization-level roles).
	Scope string
}

func (b0 Role_builder) Build() *Role {
	m0 := &Role{}
	b, x := &b0, m0
	_, _ = b, x
	x.Id = b.Id
	x.Permissions = b.Permissions
	x.InheritedRoleIds = b.InheritedRoleIds
	x.Scope = b.Scope
	return m0
}

// Wraps around a session to include signature.
type SignedSession struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// The session that is signed.
	Session *Session `protobuf:"bytes,1,opt,name=session,proto3" json:"session,omitempty"`
	// Cryptographic signature of the session data to ensure integrity and prevent tampering.
	Signature     []byte `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SignedSession) Reset() {
	*x = SignedSession{}
	mi := &file_malonaz_authentication_v1_authentication_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SignedSession) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SignedSession) ProtoMessage() {}

func (x *SignedSession) ProtoReflect() protoreflect.Message {
	mi := &file_malonaz_authentication_v1_authentication_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *SignedSession) GetSession() *Session {
	if x != nil {
		return x.Session
	}
	return nil
}

func (x *SignedSession) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *SignedSession) SetSession(v *Session) {
	x.Session = v
}

func (x *SignedSession) SetSignature(v []byte) {
	if v == nil {
		v = []byte{}
	}
	x.Signature = v
}

func (x *SignedSession) HasSession() bool {
	if x == nil {
		return false
	}
	return x.Session != nil
}

func (x *SignedSession) ClearSession() {
	x.Session = nil
}

type SignedSession_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// The session that is signed.
	Session *Session
	// Cryptographic signature of the session data to ensure integrity and prevent tampering.
	Signature []byte
}

func (b0 SignedSession_builder) Build() *SignedSession {
	m0 := &SignedSession{}
	b, x := &b0, m0
	_, _ = b, x
	x.Session = b.Session
	x.Signature = b.Signature
	return m0
}

// Session represents an authenticated session for either a user or service account,
// containing identity information, permissions, and metadata about the session.
type Session struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Unique identifier for this session instance.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Time at which this session was created.
	CreateTime *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	// Identity that owns this session (mutually exclusive)
	//
	// Types that are valid to be assigned to Identity:
	//
	//	*Session_UserIdentity
	//	*Session_ServiceAccountIdentity
	Identity isSession_Identity `protobuf_oneof:"identity"`
	// An authorized session does not get checked again method permissions.
	// We only check at edges entry point.
	// For example, let's look at an external call:
	//   - Call serviceA.Method1: we verify permissions and if valid, set `authorized=true`
	//   - serviceA.Method1 calls serviceB.Method2: the session is authorized so we do not verify permissions.
	Authorized bool `protobuf:"varint,5,opt,name=authorized,proto3" json:"authorized,omitempty"`
	// The labels on this sessino.
	Labels map[string]string `protobuf:"bytes,6,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Additional metadata about the session, including client information
	// and context for logging and auditing purposes.
	Metadata      *SessionMetadata `protobuf:"bytes,7,opt,name=metadata,proto3" json:"metadata,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Session) Reset() {
	*x = Session{}
	mi := &file_malonaz_authentication_v1_authentication_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Session) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Session) ProtoMessage() {}

func (x *Session) ProtoReflect() protoreflect.Message {
	mi := &file_malonaz_authentication_v1_authentication_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *Session) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Session) GetCreateTime() *timestamppb.Timestamp {
	if x != nil {
		return x.CreateTime
	}
	return nil
}

func (x *Session) GetIdentity() isSession_Identity {
	if x != nil {
		return x.Identity
	}
	return nil
}

func (x *Session) GetUserIdentity() *UserIdentity {
	if x != nil {
		if x, ok := x.Identity.(*Session_UserIdentity); ok {
			return x.UserIdentity
		}
	}
	return nil
}

func (x *Session) GetServiceAccountIdentity() *ServiceAccountIdentity {
	if x != nil {
		if x, ok := x.Identity.(*Session_ServiceAccountIdentity); ok {
			return x.ServiceAccountIdentity
		}
	}
	return nil
}

func (x *Session) GetAuthorized() bool {
	if x != nil {
		return x.Authorized
	}
	return false
}

func (x *Session) GetLabels() map[string]string {
	if x != nil {
		return x.Labels
	}
	return nil
}

func (x *Session) GetMetadata() *SessionMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *Session) SetId(v string) {
	x.Id = v
}

func (x *Session) SetCreateTime(v *timestamppb.Timestamp) {
	x.CreateTime = v
}

func (x *Session) SetUserIdentity(v *UserIdentity) {
	if v == nil {
		x.Identity = nil
		return
	}
	x.Identity = &Session_UserIdentity{v}
}

func (x *Session) SetServiceAccountIdentity(v *ServiceAccountIdentity) {
	if v == nil {
		x.Identity = nil
		return
	}
	x.Identity = &Session_ServiceAccountIdentity{v}
}

func (x *Session) SetAuthorized(v bool) {
	x.Authorized = v
}

func (x *Session) SetLabels(v map[string]string) {
	x.Labels = v
}

func (x *Session) SetMetadata(v *SessionMetadata) {
	x.Metadata = v
}

func (x *Session) HasCreateTime() bool {
	if x == nil {
		return false
	}
	return x.CreateTime != nil
}

func (x *Session) HasIdentity() bool {
	if x == nil {
		return false
	}
	return x.Identity != nil
}

func (x *Session) HasUserIdentity() bool {
	if x == nil {
		return false
	}
	_, ok := x.Identity.(*Session_UserIdentity)
	return ok
}

func (x *Session) HasServiceAccountIdentity() bool {
	if x == nil {
		return false
	}
	_, ok := x.Identity.(*Session_ServiceAccountIdentity)
	return ok
}

func (x *Session) HasMetadata() bool {
	if x == nil {
		return false
	}
	return x.Metadata != nil
}

func (x *Session) ClearCreateTime() {
	x.CreateTime = nil
}

func (x *Session) ClearIdentity() {
	x.Identity = nil
}

func (x *Session) ClearUserIdentity() {
	if _, ok := x.Identity.(*Session_UserIdentity); ok {
		x.Identity = nil
	}
}

func (x *Session) ClearServiceAccountIdentity() {
	if _, ok := x.Identity.(*Session_ServiceAccountIdentity); ok {
		x.Identity = nil
	}
}

func (x *Session) ClearMetadata() {
	x.Metadata = nil
}

const Session_Identity_not_set_case case_Session_Identity = 0
const Session_UserIdentity_case case_Session_Identity = 3
const Session_ServiceAccountIdentity_case case_Session_Identity = 4

func (x *Session) WhichIdentity() case_Session_Identity {
	if x == nil {
		return Session_Identity_not_set_case
	}
	switch x.Identity.(type) {
	case *Session_UserIdentity:
		return Session_UserIdentity_case
	case *Session_ServiceAccountIdentity:
		return Session_ServiceAccountIdentity_case
	default:
		return Session_Identity_not_set_case
	}
}

type Session_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Unique identifier for this session instance.
	Id string
	// Time at which this session was created.
	CreateTime *timestamppb.Timestamp
	// Identity that owns this session (mutually exclusive)

	// Fields of oneof Identity:
	// Human user identity
	UserIdentity *UserIdentity
	// Service account identity for programmatic access
	ServiceAccountIdentity *ServiceAccountIdentity
	// -- end of Identity
	// An authorized session does not get checked again method permissions.
	// We only check at edges entry point.
	// For example, let's look at an external call:
	//   - Call serviceA.Method1: we verify permissions and if valid, set `authorized=true`
	//   - serviceA.Method1 calls serviceB.Method2: the session is authorized so we do not verify permissions.
	Authorized bool
	// The labels on this sessino.
	Labels map[string]string
	// Additional metadata about the session, including client information
	// and context for logging and auditing purposes.
	Metadata *SessionMetadata
}

func (b0 Session_builder) Build() *Session {
	m0 := &Session{}
	b, x := &b0, m0
	_, _ = b, x
	x.Id = b.Id
	x.CreateTime = b.CreateTime
	if b.UserIdentity != nil {
		x.Identity = &Session_UserIdentity{b.UserIdentity}
	}
	if b.ServiceAccountIdentity != nil {
		x.Identity = &Session_ServiceAccountIdentity{b.ServiceAccountIdentity}
	}
	x.Authorized = b.Authorized
	x.Labels = b.Labels
	x.Metadata = b.Metadata
	return m0
}

type case_Session_Identity protoreflect.FieldNumber

func (x case_Session_Identity) String() string {
	md := file_malonaz_authentication_v1_authentication_proto_msgTypes[5].Descriptor()
	if x == 0 {
		return "not set"
	}
	return protoimpl.X.MessageFieldStringOf(md, protoreflect.FieldNumber(x))
}

type isSession_Identity interface {
	isSession_Identity()
}

type Session_UserIdentity struct {
	// Human user identity
	UserIdentity *UserIdentity `protobuf:"bytes,3,opt,name=user_identity,json=userIdentity,proto3,oneof"`
}

type Session_ServiceAccountIdentity struct {
	// Service account identity for programmatic access
	ServiceAccountIdentity *ServiceAccountIdentity `protobuf:"bytes,4,opt,name=service_account_identity,json=serviceAccountIdentity,proto3,oneof"`
}

func (*Session_UserIdentity) isSession_Identity() {}

func (*Session_ServiceAccountIdentity) isSession_Identity() {}

// Identity of a human user
type UserIdentity struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// The id of the organization the user belongs to.
	OrganizationId string `protobuf:"bytes,1,opt,name=organization_id,json=organizationId,proto3" json:"organization_id,omitempty"`
	// A unique idenfier for this user.
	UserId        string `protobuf:"bytes,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UserIdentity) Reset() {
	*x = UserIdentity{}
	mi := &file_malonaz_authentication_v1_authentication_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UserIdentity) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UserIdentity) ProtoMessage() {}

func (x *UserIdentity) ProtoReflect() protoreflect.Message {
	mi := &file_malonaz_authentication_v1_authentication_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *UserIdentity) GetOrganizationId() string {
	if x != nil {
		return x.OrganizationId
	}
	return ""
}

func (x *UserIdentity) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

func (x *UserIdentity) SetOrganizationId(v string) {
	x.OrganizationId = v
}

func (x *UserIdentity) SetUserId(v string) {
	x.UserId = v
}

type UserIdentity_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// The id of the organization the user belongs to.
	OrganizationId string
	// A unique idenfier for this user.
	UserId string
}

func (b0 UserIdentity_builder) Build() *UserIdentity {
	m0 := &UserIdentity{}
	b, x := &b0, m0
	_, _ = b, x
	x.OrganizationId = b.OrganizationId
	x.UserId = b.UserId
	return m0
}

// Identity of a service account
type ServiceAccountIdentity struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// The service account behind this identity.
	ServiceAccountId string `protobuf:"bytes,1,opt,name=service_account_id,json=serviceAccountId,proto3" json:"service_account_id,omitempty"`
	// The type of sercice account this is.
	ServiceAccountType ServiceAccountType `protobuf:"varint,2,opt,name=service_account_type,json=serviceAccountType,proto3,enum=malonaz.authentication.v1.ServiceAccountType" json:"service_account_type,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *ServiceAccountIdentity) Reset() {
	*x = ServiceAccountIdentity{}
	mi := &file_malonaz_authentication_v1_authentication_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ServiceAccountIdentity) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ServiceAccountIdentity) ProtoMessage() {}

func (x *ServiceAccountIdentity) ProtoReflect() protoreflect.Message {
	mi := &file_malonaz_authentication_v1_authentication_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *ServiceAccountIdentity) GetServiceAccountId() string {
	if x != nil {
		return x.ServiceAccountId
	}
	return ""
}

func (x *ServiceAccountIdentity) GetServiceAccountType() ServiceAccountType {
	if x != nil {
		return x.ServiceAccountType
	}
	return ServiceAccountType_SERVICE_ACCOUNT_TYPE_UNSPECIFIED
}

func (x *ServiceAccountIdentity) SetServiceAccountId(v string) {
	x.ServiceAccountId = v
}

func (x *ServiceAccountIdentity) SetServiceAccountType(v ServiceAccountType) {
	x.ServiceAccountType = v
}

type ServiceAccountIdentity_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// The service account behind this identity.
	ServiceAccountId string
	// The type of sercice account this is.
	ServiceAccountType ServiceAccountType
}

func (b0 ServiceAccountIdentity_builder) Build() *ServiceAccountIdentity {
	m0 := &ServiceAccountIdentity{}
	b, x := &b0, m0
	_, _ = b, x
	x.ServiceAccountId = b.ServiceAccountId
	x.ServiceAccountType = b.ServiceAccountType
	return m0
}

// SessionMetadata contains contextual information about a session, useful for
// logging, auditing, security monitoring, and debugging.
type SessionMetadata struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// IP address of the client that created or is using this session,
	// useful for security monitoring and geographic access tracking.
	IpAddress string `protobuf:"bytes,1,opt,name=ip_address,json=ipAddress,proto3" json:"ip_address,omitempty"`
	// Semantic version of the client application making requests with this session,
	// enabling version-specific behavior and compatibility tracking.
	ClientVersion *ClientVersion `protobuf:"bytes,2,opt,name=client_version,json=clientVersion,proto3" json:"client_version,omitempty"`
	// User-Agent string from the client, providing information about the
	// client software, operating system, and browser (if applicable).
	UserAgent     string `protobuf:"bytes,3,opt,name=user_agent,json=userAgent,proto3" json:"user_agent,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SessionMetadata) Reset() {
	*x = SessionMetadata{}
	mi := &file_malonaz_authentication_v1_authentication_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SessionMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SessionMetadata) ProtoMessage() {}

func (x *SessionMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_malonaz_authentication_v1_authentication_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *SessionMetadata) GetIpAddress() string {
	if x != nil {
		return x.IpAddress
	}
	return ""
}

func (x *SessionMetadata) GetClientVersion() *ClientVersion {
	if x != nil {
		return x.ClientVersion
	}
	return nil
}

func (x *SessionMetadata) GetUserAgent() string {
	if x != nil {
		return x.UserAgent
	}
	return ""
}

func (x *SessionMetadata) SetIpAddress(v string) {
	x.IpAddress = v
}

func (x *SessionMetadata) SetClientVersion(v *ClientVersion) {
	x.ClientVersion = v
}

func (x *SessionMetadata) SetUserAgent(v string) {
	x.UserAgent = v
}

func (x *SessionMetadata) HasClientVersion() bool {
	if x == nil {
		return false
	}
	return x.ClientVersion != nil
}

func (x *SessionMetadata) ClearClientVersion() {
	x.ClientVersion = nil
}

type SessionMetadata_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// IP address of the client that created or is using this session,
	// useful for security monitoring and geographic access tracking.
	IpAddress string
	// Semantic version of the client application making requests with this session,
	// enabling version-specific behavior and compatibility tracking.
	ClientVersion *ClientVersion
	// User-Agent string from the client, providing information about the
	// client software, operating system, and browser (if applicable).
	UserAgent string
}

func (b0 SessionMetadata_builder) Build() *SessionMetadata {
	m0 := &SessionMetadata{}
	b, x := &b0, m0
	_, _ = b, x
	x.IpAddress = b.IpAddress
	x.ClientVersion = b.ClientVersion
	x.UserAgent = b.UserAgent
	return m0
}

// ClientVersion represents a semantic version (semver) of the client application,
// following the major.minor.patch versioning scheme.
type ClientVersion struct {
	state protoimpl.MessageState `protogen:"hybrid.v1"`
	// Major version number, incremented for incompatible API changes.
	Major int32 `protobuf:"varint,1,opt,name=major,proto3" json:"major,omitempty"`
	// Minor version number, incremented for backwards-compatible functionality additions.
	Minor int32 `protobuf:"varint,2,opt,name=minor,proto3" json:"minor,omitempty"`
	// Patch version number, incremented for backwards-compatible bug fixes.
	Patch         int32 `protobuf:"varint,3,opt,name=patch,proto3" json:"patch,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClientVersion) Reset() {
	*x = ClientVersion{}
	mi := &file_malonaz_authentication_v1_authentication_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClientVersion) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClientVersion) ProtoMessage() {}

func (x *ClientVersion) ProtoReflect() protoreflect.Message {
	mi := &file_malonaz_authentication_v1_authentication_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *ClientVersion) GetMajor() int32 {
	if x != nil {
		return x.Major
	}
	return 0
}

func (x *ClientVersion) GetMinor() int32 {
	if x != nil {
		return x.Minor
	}
	return 0
}

func (x *ClientVersion) GetPatch() int32 {
	if x != nil {
		return x.Patch
	}
	return 0
}

func (x *ClientVersion) SetMajor(v int32) {
	x.Major = v
}

func (x *ClientVersion) SetMinor(v int32) {
	x.Minor = v
}

func (x *ClientVersion) SetPatch(v int32) {
	x.Patch = v
}

type ClientVersion_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Major version number, incremented for incompatible API changes.
	Major int32
	// Minor version number, incremented for backwards-compatible functionality additions.
	Minor int32
	// Patch version number, incremented for backwards-compatible bug fixes.
	Patch int32
}

func (b0 ClientVersion_builder) Build() *ClientVersion {
	m0 := &ClientVersion{}
	b, x := &b0, m0
	_, _ = b, x
	x.Major = b.Major
	x.Minor = b.Minor
	x.Patch = b.Patch
	return m0
}

var File_malonaz_authentication_v1_authentication_proto protoreflect.FileDescriptor

const file_malonaz_authentication_v1_authentication_proto_rawDesc = "" +
	"\n" +
	".malonaz/authentication/v1/authentication.proto\x12\x19malonaz.authentication.v1\x1a\x1bbuf/validate/validate.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"\x93\x03\n" +
	"\x17PermissionConfiguration\x12\xbd\x01\n" +
	"\x10service_accounts\x18\x01 \x03(\v2).malonaz.authentication.v1.ServiceAccountBg\xbaHd\xba\x01^\n" +
	"\x1aunique_service_account_ids\x12\"service account ids must be unique\x1a\x1cthis.map(sa, sa.id).unique()\xc8\x01\x01R\x0fserviceAccounts\x12\x86\x01\n" +
	"\x05roles\x18\x02 \x03(\v2\x1f.malonaz.authentication.v1.RoleBO\xbaHL\xba\x01F\n" +
	"\x0funique_role_ids\x12\x17role ids must be unique\x1a\x1athis.map(r, r.id).unique()\xc8\x01\x01R\x05roles\x12/\n" +
	"\x0epublic_methods\x18\x03 \x03(\tB\b\xbaH\x05\x92\x01\x02\x18\x01R\rpublicMethods\"{\n" +
	"\x1bServiceAccountConfiguration\x12\\\n" +
	"\x10service_accounts\x18\x01 \x03(\v2).malonaz.authentication.v1.ServiceAccountB\x06\xbaH\x03\xc8\x01\x01R\x0fserviceAccounts\"\xe1\x03\n" +
	"\x0eServiceAccount\x12\x16\n" +
	"\x02id\x18\x01 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\x02id\x12M\n" +
	"\x04type\x18\x02 \x01(\x0e2-.malonaz.authentication.v1.ServiceAccountTypeB\n" +
	"\xbaH\a\x82\x01\x04\x10\x01 \x00R\x04type\x12#\n" +
	"\brole_ids\x18\x03 \x03(\tB\b\xbaH\x05\x92\x01\x02\x18\x01R\aroleIds\x12*\n" +
	"\vpermissions\x18\x04 \x03(\tB\b\xbaH\x05\x92\x01\x02\x18\x01R\vpermissions\x12\xdb\x01\n" +
	"\x06labels\x18\x05 \x03(\v25.malonaz.authentication.v1.ServiceAccount.LabelsEntryB\x8b\x01\xbaH\x87\x01\x9a\x01\x83\x01\x10@\"drb2`^([a-zA-Z0-9]([a-zA-Z0-9.-]{0,251}[a-zA-Z0-9])?/)?[a-zA-Z0-9]([a-zA-Z0-9_.-]{0,61}[a-zA-Z0-9])?$*\x19r\x17\x18?2\x13^[a-z0-9_\\-\\p{L}]*$R\x06labels\x1a9\n" +
	"\vLabelsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x90\x01\n" +
	"\x04Role\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12*\n" +
	"\vpermissions\x18\x02 \x03(\tB\b\xbaH\x05\x92\x01\x02\x18\x01R\vpermissions\x126\n" +
	"\x12inherited_role_ids\x18\x03 \x03(\tB\b\xbaH\x05\x92\x01\x02\x18\x01R\x10inheritedRoleIds\x12\x14\n" +
	"\x05scope\x18\x04 \x01(\tR\x05scope\"k\n" +
	"\rSignedSession\x12<\n" +
	"\asession\x18\x01 \x01(\v2\".malonaz.authentication.v1.SessionR\asession\x12\x1c\n" +
	"\tsignature\x18\x02 \x01(\fR\tsignature\"\x9b\x05\n" +
	"\aSession\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12;\n" +
	"\vcreate_time\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"createTime\x12N\n" +
	"\ruser_identity\x18\x03 \x01(\v2'.malonaz.authentication.v1.UserIdentityH\x00R\fuserIdentity\x12m\n" +
	"\x18service_account_identity\x18\x04 \x01(\v21.malonaz.authentication.v1.ServiceAccountIdentityH\x00R\x16serviceAccountIdentity\x12\x1e\n" +
	"\n" +
	"authorized\x18\x05 \x01(\bR\n" +
	"authorized\x12\xd4\x01\n" +
	"\x06labels\x18\x06 \x03(\v2..malonaz.authentication.v1.Session.LabelsEntryB\x8b\x01\xbaH\x87\x01\x9a\x01\x83\x01\x10@\"drb2`^([a-zA-Z0-9]([a-zA-Z0-9.-]{0,251}[a-zA-Z0-9])?/)?[a-zA-Z0-9]([a-zA-Z0-9_.-]{0,61}[a-zA-Z0-9])?$*\x19r\x17\x18?2\x13^[a-z0-9_\\-\\p{L}]*$R\x06labels\x12F\n" +
	"\bmetadata\x18\a \x01(\v2*.malonaz.authentication.v1.SessionMetadataR\bmetadata\x1a9\n" +
	"\vLabelsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01B\n" +
	"\n" +
	"\bidentity\"P\n" +
	"\fUserIdentity\x12'\n" +
	"\x0forganization_id\x18\x01 \x01(\tR\x0eorganizationId\x12\x17\n" +
	"\auser_id\x18\x02 \x01(\tR\x06userId\"\xb3\x01\n" +
	"\x16ServiceAccountIdentity\x12,\n" +
	"\x12service_account_id\x18\x01 \x01(\tR\x10serviceAccountId\x12k\n" +
	"\x14service_account_type\x18\x02 \x01(\x0e2-.malonaz.authentication.v1.ServiceAccountTypeB\n" +
	"\xbaH\a\x82\x01\x04\x10\x01 \x00R\x12serviceAccountType\"\xa0\x01\n" +
	"\x0fSessionMetadata\x12\x1d\n" +
	"\n" +
	"ip_address\x18\x01 \x01(\tR\tipAddress\x12O\n" +
	"\x0eclient_version\x18\x02 \x01(\v2(.malonaz.authentication.v1.ClientVersionR\rclientVersion\x12\x1d\n" +
	"\n" +
	"user_agent\x18\x03 \x01(\tR\tuserAgent\"Q\n" +
	"\rClientVersion\x12\x14\n" +
	"\x05major\x18\x01 \x01(\x05R\x05major\x12\x14\n" +
	"\x05minor\x18\x02 \x01(\x05R\x05minor\x12\x14\n" +
	"\x05patch\x18\x03 \x01(\x05R\x05patch*\x87\x01\n" +
	"\x12ServiceAccountType\x12$\n" +
	" SERVICE_ACCOUNT_TYPE_UNSPECIFIED\x10\x00\x12 \n" +
	"\x1cSERVICE_ACCOUNT_TYPE_API_KEY\x10\x01\x12)\n" +
	"%SERVICE_ACCOUNT_TYPE_INTERNAL_SERVICE\x10\x02B4Z2github.com/malonaz/core/genproto/authentication/v1b\x06proto3"

var file_malonaz_authentication_v1_authentication_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_malonaz_authentication_v1_authentication_proto_msgTypes = make([]protoimpl.MessageInfo, 12)
var file_malonaz_authentication_v1_authentication_proto_goTypes = []any{
	(ServiceAccountType)(0),             // 0: malonaz.authentication.v1.ServiceAccountType
	(*PermissionConfiguration)(nil),     // 1: malonaz.authentication.v1.PermissionConfiguration
	(*ServiceAccountConfiguration)(nil), // 2: malonaz.authentication.v1.ServiceAccountConfiguration
	(*ServiceAccount)(nil),              // 3: malonaz.authentication.v1.ServiceAccount
	(*Role)(nil),                        // 4: malonaz.authentication.v1.Role
	(*SignedSession)(nil),               // 5: malonaz.authentication.v1.SignedSession
	(*Session)(nil),                     // 6: malonaz.authentication.v1.Session
	(*UserIdentity)(nil),                // 7: malonaz.authentication.v1.UserIdentity
	(*ServiceAccountIdentity)(nil),      // 8: malonaz.authentication.v1.ServiceAccountIdentity
	(*SessionMetadata)(nil),             // 9: malonaz.authentication.v1.SessionMetadata
	(*ClientVersion)(nil),               // 10: malonaz.authentication.v1.ClientVersion
	nil,                                 // 11: malonaz.authentication.v1.ServiceAccount.LabelsEntry
	nil,                                 // 12: malonaz.authentication.v1.Session.LabelsEntry
	(*timestamppb.Timestamp)(nil),       // 13: google.protobuf.Timestamp
}
var file_malonaz_authentication_v1_authentication_proto_depIdxs = []int32{
	3,  // 0: malonaz.authentication.v1.PermissionConfiguration.service_accounts:type_name -> malonaz.authentication.v1.ServiceAccount
	4,  // 1: malonaz.authentication.v1.PermissionConfiguration.roles:type_name -> malonaz.authentication.v1.Role
	3,  // 2: malonaz.authentication.v1.ServiceAccountConfiguration.service_accounts:type_name -> malonaz.authentication.v1.ServiceAccount
	0,  // 3: malonaz.authentication.v1.ServiceAccount.type:type_name -> malonaz.authentication.v1.ServiceAccountType
	11, // 4: malonaz.authentication.v1.ServiceAccount.labels:type_name -> malonaz.authentication.v1.ServiceAccount.LabelsEntry
	6,  // 5: malonaz.authentication.v1.SignedSession.session:type_name -> malonaz.authentication.v1.Session
	13, // 6: malonaz.authentication.v1.Session.create_time:type_name -> google.protobuf.Timestamp
	7,  // 7: malonaz.authentication.v1.Session.user_identity:type_name -> malonaz.authentication.v1.UserIdentity
	8,  // 8: malonaz.authentication.v1.Session.service_account_identity:type_name -> malonaz.authentication.v1.ServiceAccountIdentity
	12, // 9: malonaz.authentication.v1.Session.labels:type_name -> malonaz.authentication.v1.Session.LabelsEntry
	9,  // 10: malonaz.authentication.v1.Session.metadata:type_name -> malonaz.authentication.v1.SessionMetadata
	0,  // 11: malonaz.authentication.v1.ServiceAccountIdentity.service_account_type:type_name -> malonaz.authentication.v1.ServiceAccountType
	10, // 12: malonaz.authentication.v1.SessionMetadata.client_version:type_name -> malonaz.authentication.v1.ClientVersion
	13, // [13:13] is the sub-list for method output_type
	13, // [13:13] is the sub-list for method input_type
	13, // [13:13] is the sub-list for extension type_name
	13, // [13:13] is the sub-list for extension extendee
	0,  // [0:13] is the sub-list for field type_name
}

func init() { file_malonaz_authentication_v1_authentication_proto_init() }
func file_malonaz_authentication_v1_authentication_proto_init() {
	if File_malonaz_authentication_v1_authentication_proto != nil {
		return
	}
	file_malonaz_authentication_v1_authentication_proto_msgTypes[5].OneofWrappers = []any{
		(*Session_UserIdentity)(nil),
		(*Session_ServiceAccountIdentity)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_malonaz_authentication_v1_authentication_proto_rawDesc), len(file_malonaz_authentication_v1_authentication_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   12,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_malonaz_authentication_v1_authentication_proto_goTypes,
		DependencyIndexes: file_malonaz_authentication_v1_authentication_proto_depIdxs,
		EnumInfos:         file_malonaz_authentication_v1_authentication_proto_enumTypes,
		MessageInfos:      file_malonaz_authentication_v1_authentication_proto_msgTypes,
	}.Build()
	File_malonaz_authentication_v1_authentication_proto = out.File
	file_malonaz_authentication_v1_authentication_proto_goTypes = nil
	file_malonaz_authentication_v1_authentication_proto_depIdxs = nil
}
