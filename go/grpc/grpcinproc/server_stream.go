package grpcinproc

import (
	"context"
	"errors"
	"io"
	"iter"

	"google.golang.org/grpc"
	"google.golang.org/grpc/metadata"
)

// ServerStreamClient allows receiving messages from a server stream.
type ServerStreamClient[T any] interface {
	Recv() (*T, error)
	CloseSend() error
	grpc.ClientStream
}

// ServerStreamServer allows sending messages in a server stream.
type ServerStreamServer[T any] interface {
	Send(*T) error
	Context() context.Context
}

// GrpcServerStreamStream represents the full gRPC server streaming interface.
// This matches the interface generated by protoc-gen-go-grpc for server streams.
type GrpcServerStreamStream[T any] interface {
	Send(*T) error
	grpc.ServerStream // Embed the full ServerStream interface
}

// NewServerStreamAsClient converts a server-streaming implementation into a client interface.
// This allows calling server implementations directly without going through gRPC.
func NewServerStreamAsClient[Req, Resp any, Srv grpc.ServerStream](
	handler func(*Req, Srv) error,
) func(context.Context, *Req) (ServerStreamClient[Resp], error) {
	return func(ctx context.Context, req *Req) (ServerStreamClient[Resp], error) {
		y := &serverStreamYielder[Resp]{ctx: ctx}

		// Pull from iter.Seq2[*Resp, error].
		y.recv, y.stop = iter.Pull2(func(yield func(*Resp, error) bool) {
			y.send = yield
			// Create a server stream adapter that implements Srv
			srv := newServerStreamAdapter[Resp](y)
			// Type assert to Srv - this works because serverStreamAdapter implements grpc.ServerStream
			// and the concrete type Srv will have Send(*Resp) error method
			if err := handler(req, any(srv).(Srv)); err != nil {
				yield(nil, err)
				return
			}
		})
		return y, nil
	}
}

type serverStreamYielder[T any] struct {
	ctx context.Context

	send func(*T, error) bool
	recv func() (*T, error, bool)
	stop func()
}

func (y *serverStreamYielder[T]) Context() context.Context {
	return y.ctx
}

func (y *serverStreamYielder[T]) Send(resp *T) error {
	if !y.send(resp, nil) {
		return errors.New("iterator stopped receiving")
	}
	return nil
}

func (y *serverStreamYielder[T]) Recv() (*T, error) {
	r, err, ok := y.recv()
	if err != nil {
		y.stop()
		return nil, err
	}
	if !ok {
		return nil, io.EOF
	}
	return r, nil
}

func (y *serverStreamYielder[T]) CloseSend() error {
	y.stop()
	return nil
}

// grpc.ClientStream interface methods for serverStreamYielder
func (y *serverStreamYielder[T]) Header() (metadata.MD, error) {
	return metadata.MD{}, nil
}

func (y *serverStreamYielder[T]) Trailer() metadata.MD {
	return metadata.MD{}
}

func (y *serverStreamYielder[T]) SendMsg(m interface{}) error {
	return errors.New("SendMsg not supported on client stream")
}

func (y *serverStreamYielder[T]) RecvMsg(m interface{}) error {
	msg, err := y.Recv()
	if err != nil {
		return err
	}
	if ptr, ok := m.(*T); ok {
		*ptr = *msg
		return nil
	}
	return errors.New("RecvMsg: invalid message type")
}

// serverStreamAdapter adapts ServerStreamServer to the full gRPC server streaming interface.
type serverStreamAdapter[T any] struct {
	srv ServerStreamServer[T]
}

func (a *serverStreamAdapter[T]) Send(resp *T) error {
	return a.srv.Send(resp)
}

func (a *serverStreamAdapter[T]) Context() context.Context {
	return a.srv.Context()
}

// grpc.ServerStream interface methods
func (a *serverStreamAdapter[T]) SetHeader(md metadata.MD) error {
	return nil
}

func (a *serverStreamAdapter[T]) SendHeader(md metadata.MD) error {
	return nil
}

func (a *serverStreamAdapter[T]) SetTrailer(md metadata.MD) {
}

func (a *serverStreamAdapter[T]) SendMsg(m interface{}) error {
	// For local calls, delegate to Send if m is the right type
	if msg, ok := m.(*T); ok {
		return a.Send(msg)
	}
	return errors.New("SendMsg: invalid message type")
}

func (a *serverStreamAdapter[T]) RecvMsg(m interface{}) error {
	return errors.New("RecvMsg not supported on server stream")
}

// newServerStreamAdapter creates a new adapter that wraps a ServerStreamServer
// to implement the full gRPC server streaming interface.
func newServerStreamAdapter[T any](srv ServerStreamServer[T]) GrpcServerStreamStream[T] {
	return &serverStreamAdapter[T]{srv: srv}
}
