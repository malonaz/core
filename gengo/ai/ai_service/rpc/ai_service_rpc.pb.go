// Code generated by protoc-templates. DO NOT EDIT.
// source: malonaz/ai/ai_service/v1/ai_service.proto
package rpc

import (
	context "context"
	errors "errors"
	model "github.com/malonaz/core/gengo/ai/model"
	v1 "github.com/malonaz/core/genproto/ai/ai_service/v1"
	v11 "github.com/malonaz/core/genproto/ai/v1"
	aip "github.com/malonaz/core/go/aip"
	grpc "github.com/malonaz/core/go/grpc"
	uuid "github.com/malonaz/core/go/uuid"
	resourcename "go.einride.tech/aip/resourcename"
	codes "google.golang.org/grpc/codes"
	metadata "google.golang.org/grpc/metadata"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	time "time"
)

type aiServiceStore interface {
	aiService_ChatStore
}

type AiServiceServer struct {
	*aiService_ChatServer
}

func NewAiServiceServer(store aiServiceStore) *AiServiceServer {
	return &AiServiceServer{
		newAiService_ChatServer(store),
	}
}

type aiService_ChatStore interface {
	InsertChatIdempotently(ctx context.Context, requestID string, chat *model.Chat) (*model.Chat, error)

	UpdateChat(ctx context.Context, chat *model.Chat, updateClause string, columns []string, etag string) (*model.Chat, error)

	SoftDeleteChat(ctx context.Context, organizationId, userId, chatId string, etag, newEtag string, deleteTime time.Time) (*model.Chat, error)

	GetChat(ctx context.Context, organizationId, userId, chatId string) (*model.Chat, error)
	ListChats(ctx context.Context, organizationId, userId string, showDeleted bool, whereClause, orderByClause, paginationClause string, dbColumns []string, whereParams ...any) ([]*model.Chat, error)
}

// Server implements the RPC interface.
type aiService_ChatServer struct {
	store aiService_ChatStore
}

// Instantiate a new server.
func newAiService_ChatServer(store aiService_ChatStore) *aiService_ChatServer {
	return &aiService_ChatServer{
		store: store,
	}
}

// CreateChat creates a Chat
func (s *aiService_ChatServer) CreateChat(ctx context.Context, request *v1.CreateChatRequest) (*v11.Chat, error) {
	// STEP 1: Set identifiers.

	if request.RequestId == "" { // We always set a request id.
		request.RequestId = uuid.MustNewV7().String()
	}

	chatId := request.ChatId
	if chatId == "" {
		chatId = aip.NewSystemGeneratedBase32ResourceID()
	}

	var organizationId, userId string
	if err := resourcename.Sscan(request.Parent, "organizations/{organization}/users/{user}", &organizationId, &userId); err != nil {
		return nil, grpc.Errorf(codes.InvalidArgument, "invalid parent name: %v", err).Err()
	}

	request.Chat.Name = resourcename.Sprint("organizations/{organization}/users/{user}/chats/{chat}", organizationId, userId, chatId)

	// STEP 2: Instantiate timestamps.
	// Check for x-migration-request header
	if values := metadata.ValueFromIncomingContext(ctx, "x-migration-request"); len(values) > 0 {
		if request.Chat.CreateTime == nil {
			return nil, grpc.Errorf(codes.InvalidArgument, "x-migration-request used without setting a create_time").Err()
		}
	} else {
		request.Chat.CreateTime = timestamppb.Now()
	}
	request.Chat.UpdateTime = request.Chat.CreateTime

	{ // Capture the etag.
		var err error
		request.Chat.Etag, err = aip.ComputeETag(request.Chat)
		if err != nil {
			return nil, grpc.Errorf(codes.Internal, "computing etag: %v", err).Err()
		}
	}

	// STEP 3: Convert the resource to the database representation.
	chatModel, err := model.ChatFromPb(request.Chat)
	if err != nil {
		return nil, grpc.Errorf(codes.Internal, "converting chat from pb to model: %v", err).Err()
	}
	if request.ValidateOnly {
		return request.Chat, nil
	}

	// STEP 4: Insert the resource idempotently.
	dbChatModel, err := s.store.InsertChatIdempotently(ctx, request.RequestId, chatModel)
	if err != nil {
		if errors.Is(err, model.ErrChatAlreadyExists) {
			return nil, grpc.Errorf(codes.AlreadyExists, "chat already exists").Err()
		}
		return nil, grpc.Errorf(codes.Internal, "inserting chat: %v", err).Err()
	}

	chat, err := dbChatModel.ToPb()
	if err != nil {
		return nil, grpc.Errorf(codes.Internal, "converting chat from model to pb: %v", err).Err()
	}
	return chat, nil
}

func (s *aiService_ChatServer) GetChat(ctx context.Context, request *v1.GetChatRequest) (*v11.Chat, error) {
	if resourcename.ContainsWildcard(request.Name) {
		return nil, grpc.Errorf(codes.InvalidArgument, "cannot use wildcard").Err()
	}

	organizationId, userId, chatId, err := model.ParseChatName(request.Name)
	if err != nil {
		return nil, grpc.Errorf(codes.InvalidArgument, "parsing name: %v", err).Err()
	}

	// Retrieve from the database.
	dbChatModel, err := s.store.GetChat(ctx, organizationId, userId, chatId)
	if err != nil {
		if errors.Is(err, model.ErrChatNotExist) {
			return nil, grpc.Errorf(codes.NotFound, "chat does not exist").Err()
		}
		return nil, grpc.Errorf(codes.Internal, "getting chat: %v", err).Err()
	}

	chat, err := dbChatModel.ToPb()
	if err != nil {
		return nil, grpc.Errorf(codes.Internal, "converting chat from model to pb: %v", err).Err()
	}
	return chat, nil
}

var updateChatRequestParser = aip.MustNewUpdateRequestParser[*v1.UpdateChatRequest, *v11.Chat]()

func (s *aiService_ChatServer) UpdateChat(ctx context.Context, request *v1.UpdateChatRequest) (*v11.Chat, error) {
	if len(request.GetUpdateMask().GetPaths()) == 0 {
		return nil, grpc.Errorf(codes.InvalidArgument, "missing update_mask.paths").Err()
	}
	if resourcename.ContainsWildcard(request.Chat.Name) {
		return nil, grpc.Errorf(codes.InvalidArgument, "cannot use wildcard").Err()
	}
	// Set the update time.
	request.UpdateMask.Paths = append(request.UpdateMask.Paths, "update_time")
	request.Chat.UpdateTime = timestamppb.Now()
	// Capture the etag.
	etag := request.GetChat().GetEtag()
	request.UpdateMask.Paths = append(request.UpdateMask.Paths, "etag")

	// STEP 1: Parse request.
	parsedRequest, err := updateChatRequestParser.Parse(request)
	if err != nil {
		return nil, grpc.Errorf(codes.InvalidArgument, "parsing request: %v", err).Err()
	}

	// STEP 2: retrieve existing resource.
	getChatRequest := &v1.GetChatRequest{Name: request.Chat.Name}
	patchedChat, err := s.GetChat(ctx, getChatRequest)
	if err != nil {
		return nil, err
	}
	if patchedChat.DeleteTime != nil {
		return nil, grpc.Errorf(codes.NotFound, "chat does not exist").Err()
	}

	// STEP 3: Patch the existing resource.
	if err := parsedRequest.ApplyFieldMask(patchedChat, request.Chat); err != nil {
		return nil, grpc.Errorf(codes.InvalidArgument, "applying field mask: %v", err).Err()
	}

	{ // Compute the new etag.
		var err error
		patchedChat.Etag, err = aip.ComputeETag(patchedChat)
		if err != nil {
			return nil, grpc.Errorf(codes.Internal, "computing new etag: %v", err).Err()
		}
	}

	// STEP 4: Insert patched resource.
	chatModel, err := model.ChatFromPb(patchedChat)
	if err != nil {
		return nil, grpc.Errorf(codes.Internal, "converting chat from pb to model: %v", err).Err()
	}
	dbChatModel, err := s.store.UpdateChat(ctx, chatModel, parsedRequest.GetSQLUpdateClause(), parsedRequest.GetSQLColumns(), etag)
	if err != nil {
		if errors.Is(err, model.ErrChatNotExist) {
			return nil, grpc.Errorf(codes.NotFound, "chat does not exist").Err()
		}

		if errors.Is(err, model.ErrChatETagChanged) {
			return nil, grpc.Errorf(codes.Aborted, "ETag changed").Err()
		}

		return nil, grpc.Errorf(codes.Internal, "inserting chat: %v", err).Err()
	}

	chat, err := dbChatModel.ToPb()
	if err != nil {
		return nil, grpc.Errorf(codes.Internal, "converting chat from model to pb: %v", err).Err()
	}
	return chat, nil
}

func (s *aiService_ChatServer) DeleteChat(ctx context.Context, request *v1.DeleteChatRequest) (*v11.Chat, error) {
	// STEP 1: Parse resource name.
	organizationId, userId, chatId, err := model.ParseChatName(request.Name)
	if err != nil {
		return nil, grpc.Errorf(codes.InvalidArgument, "parsing name: %v", err).Err()
	}
	deleteTime := time.Now()

	// Compute new etag.
	getChatRequest := &v1.GetChatRequest{Name: request.Name}
	Chat, err := s.GetChat(ctx, getChatRequest)
	if err != nil {
		return nil, err
	}
	Chat.DeleteTime = timestamppb.New(deleteTime)
	newEtag, err := aip.ComputeETag(Chat)
	if err != nil {
		return nil, grpc.Errorf(codes.Internal, "computing etag: %v", err).Err()
	}

	// STEP 2: Soft delete the resource.
	dbChatModel, err := s.store.SoftDeleteChat(ctx, organizationId, userId, chatId, request.GetEtag(), newEtag, deleteTime)
	if err != nil {
		if errors.Is(err, model.ErrChatNotExist) {
			return nil, grpc.Errorf(codes.NotFound, "chat does not exist").Err()
		}

		if errors.Is(err, model.ErrChatETagChanged) {
			return nil, grpc.Errorf(codes.Aborted, "ETag changed").Err()
		}

		if errors.Is(err, model.ErrChatAlreadyDeleted) {
			if request.AllowMissing {
				getChatRequest := &v1.GetChatRequest{Name: request.Name}
				return s.GetChat(ctx, getChatRequest)
			}
			return nil, grpc.Errorf(codes.NotFound, "chat already deleted").Err()
		}
		return nil, grpc.Errorf(codes.Internal, "soft deleting chat: %v", err).Err()
	}

	// STEP 3: Convert to protobuf and return.
	chat, err := dbChatModel.ToPb()
	if err != nil {
		return nil, grpc.Errorf(codes.Internal, "converting chat from model to pb: %v", err).Err()
	}
	return chat, nil

}

var listChatsRequestParser = aip.MustNewListRequestParser[*v1.ListChatsRequest, *v11.Chat]()

func (s *aiService_ChatServer) ListChats(ctx context.Context, request *v1.ListChatsRequest) (*v1.ListChatsResponse, error) {

	// Parse parent names
	var organizationId, userId string
	if err := resourcename.Sscan(request.Parent, "organizations/{organization}/users/{user}", &organizationId, &userId); err != nil {
		return nil, grpc.Errorf(codes.InvalidArgument, "invalid parent name: %v", err).Err()
	}

	// Parse request
	parsedRequest, err := listChatsRequestParser.Parse(request)
	if err != nil {
		return nil, grpc.Errorf(codes.InvalidArgument, err.Error()).Err()
	}
	whereClause, whereParams := parsedRequest.GetSQLWhereClause()
	var dbColumns []string

	// Retrieve from the database.
	dbChats, err := s.store.ListChats(ctx, organizationId, userId, request.ShowDeleted, whereClause, parsedRequest.GetSQLOrderByClause(), parsedRequest.GetSQLPaginationClause(), dbColumns, whereParams...)
	if err != nil {
		return nil, grpc.Errorf(codes.Internal, "listing chat: %v", err).Err()
	}
	nextPageToken := parsedRequest.GetNextPageToken(len(dbChats))
	if nextPageToken != "" {
		dbChats = dbChats[:len(dbChats)-1]
	}

	// Convert back to proto.
	chats := make([]*v11.Chat, 0, len(dbChats))
	for _, dbChat := range dbChats {
		chat, err := dbChat.ToPb()
		if err != nil {
			return nil, grpc.Errorf(codes.Internal, "converting model.Chat to Chat: %v", err).Err()
		}
		chats = append(chats, chat)
	}

	// Create and return response.
	return &v1.ListChatsResponse{
		Chats:         chats,
		NextPageToken: nextPageToken,
	}, nil
}
