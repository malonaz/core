// Code generated by protoc-templates. DO NOT EDIT.
// source: malonaz/ai/v1/chat.proto
package store

import (
	model "github.com/malonaz/core/gengo/ai/model"
	postgres "github.com/malonaz/core/go/postgres"
	time "time"
)

import (
	"context"
	"fmt"
	"strings"

	"github.com/jackc/pgx/v5"
)

// Store is this service's db layer.
type Store struct {
	client *postgres.Client
}

// New returns a new db.
func New(client *postgres.Client) *Store {
	return &Store{client: client}
}

var (
	ChatPostgresColumns = postgres.GetDBColumns(model.Chat{})
)

func (s *Store) getChatETag(ctx context.Context, organizationId, userId, chatId string) (string, error) {
	query := `SELECT etag FROM chat WHERE organization_id = $1 AND user_id = $2 AND chat_id = $3`
	rows, err := s.client.Query(ctx, query, organizationId, userId, chatId)
	if err != nil {
		return "", err
	}
	return pgx.CollectOneRow(rows, pgx.RowTo[string])
}

var (
	ChatWithRequestIDPostgresColumns     = postgres.GetDBColumns(ChatWithRequestID{})
	_chatInsertPostgresQuery             = `INSERT INTO chat %s VALUES %s ON CONFLICT(organization_id, user_id, chat_id) DO UPDATE SET chat_id = EXCLUDED.chat_id RETURNING `
	chatWithRequestIDInsertPostgresQuery = _chatInsertPostgresQuery + postgres.SelectQuery("%s", ChatWithRequestIDPostgresColumns)
	chatInsertPostgresQuery              = _chatInsertPostgresQuery + postgres.SelectQuery("%s", ChatPostgresColumns)
)

func (s *Store) InsertChat(ctx context.Context, chat *model.Chat) (*model.Chat, error) {
	query, params := postgres.InsertQuery(chatInsertPostgresQuery, chat)

	rows, err := s.client.Query(ctx, query, params...)
	if err != nil {
		return nil, err
	}
	row, err := pgx.CollectOneRow(rows, pgx.RowToAddrOfStructByNameLax[model.Chat])
	if err != nil {
		return nil, err
	}
	return row, nil

}

type ChatWithRequestID struct {
	RequestID string `db:"request_id"`
	model.Chat
}

var chatGetByRequestIDQuery = `SELECT ` + postgres.SelectQuery("%s", ChatPostgresColumns) + ` FROM chat WHERE request_id = $1`

func (s *Store) InsertChatIdempotently(ctx context.Context, requestID string, rawChat *model.Chat) (*model.Chat, error) {
	chat := &ChatWithRequestID{
		RequestID: requestID,
		Chat:      *rawChat,
	}
	query, params := postgres.InsertQuery(chatWithRequestIDInsertPostgresQuery, chat)

	var inserted *model.Chat
	transactionFN := func(tx postgres.Tx) error {
		inserted = nil

		// Check for existing request_id (idempotent retry)
		rows, err := tx.Query(ctx, chatGetByRequestIDQuery, requestID)
		if err != nil {
			return err
		}
		existing, err := pgx.CollectOneRow(rows, pgx.RowToAddrOfStructByNameLax[model.Chat])
		if err == nil {
			inserted = existing
			return nil
		}
		if err != pgx.ErrNoRows {
			return err
		}

		// Insert new row
		rows, err = tx.Query(ctx, query, params...)
		if err != nil {
			return err
		}
		row, err := pgx.CollectOneRow(rows, pgx.RowToAddrOfStructByNameLax[ChatWithRequestID])
		if err != nil {
			return err
		}
		if row.RequestID != requestID {
			return model.ErrChatAlreadyExists
		}
		inserted = &row.Chat

		return nil
	}

	if err := s.client.ExecuteTransaction(ctx, postgres.ReadCommitted, transactionFN); err != nil {
		return nil, err
	}
	return inserted, nil
}

var updateChatPostgresQuery = `UPDATE chat SET #update_clause# WHERE #where_clause# ` +
	postgres.SelectQuery("RETURNING %s", ChatPostgresColumns)

func (s *Store) UpdateChat(ctx context.Context, chat *model.Chat, updateClause string, updateColumns []string, etag string) (*model.Chat, error) {
	// Get update params from the object using the provided columns
	updateParams := postgres.GetParams(chat, updateColumns...)

	query := strings.Replace(updateChatPostgresQuery, "#update_clause#", updateClause, 1)
	// Build WHERE clause with correct placeholders accounting for update params
	numUpdateParams := len(updateParams)
	whereClause := fmt.Sprintf("organization_id = $%d AND user_id = $%d AND chat_id = $%d", numUpdateParams+1, numUpdateParams+2, numUpdateParams+3)
	query = strings.Replace(query, "#where_clause#", whereClause, 1)

	// Combine params: update params first, then WHERE clause params
	params := append(updateParams,
		chat.OrganizationID,
		chat.UserID,
		chat.ChatID,
	)
	if etag != "" {
		query = strings.Replace(query, "RETURNING", fmt.Sprintf("AND etag = $%d RETURNING", len(params)+1), 1)
		params = append(params, etag)
	}

	rows, err := s.client.Query(ctx, query, params...)
	if err != nil {
		return nil, err
	}
	row, err := pgx.CollectOneRow(rows, pgx.RowToAddrOfStructByNameLax[model.Chat])
	if err != nil {
		if err == pgx.ErrNoRows {
			if etag != "" {
				currentEtag, getEtagErr := s.getChatETag(ctx, chat.OrganizationID, chat.UserID, chat.ChatID)
				switch getEtagErr {
				case nil:
					if currentEtag == etag { // Should never happen.
						return nil, fmt.Errorf("update matched no rows but etag unchanged: expected etag mismatch")
					}
					return nil, model.ErrChatETagChanged
				case pgx.ErrNoRows:
					return nil, model.ErrChatNotExist // Confirmed does not exist.
				default:
					return nil, fmt.Errorf("getting etag: %v", getEtagErr)
				}
			}
			return nil, model.ErrChatNotExist
		}
		return nil, err
	}
	return row, nil
}

var softDeleteChatPostgresQuery = `UPDATE chat SET delete_time = COALESCE(delete_time, $4), etag = $5 WHERE organization_id = $1 AND user_id = $2 AND chat_id = $3 RETURNING (delete_time < $4) AS was_already_deleted, ` +
	postgres.SelectQuery("%s", ChatPostgresColumns)

type softDeleteChatResult struct {
	WasAlreadyDeleted bool `db:"was_already_deleted"`
	model.Chat
}

func (s *Store) SoftDeleteChat(ctx context.Context, organizationId, userId, chatId string, etag, newEtag string, deleteTime time.Time) (*model.Chat, error) {
	query := softDeleteChatPostgresQuery
	params := []any{organizationId, userId, chatId, deleteTime, newEtag}
	if etag != "" {
		query = strings.Replace(query, "RETURNING", fmt.Sprintf("AND etag = $%d RETURNING", len(params)+1), 1)
		params = append(params, etag)
	}
	rows, err := s.client.Query(ctx, query, params...)
	if err != nil {
		return nil, fmt.Errorf("soft deleting chat: %w", err)
	}
	row, err := pgx.CollectOneRow(rows, pgx.RowToAddrOfStructByNameLax[softDeleteChatResult])
	if err != nil {
		if err == pgx.ErrNoRows {
			if etag != "" {
				currentEtag, getEtagErr := s.getChatETag(ctx, organizationId, userId, chatId)
				switch getEtagErr {
				case nil:
					if currentEtag == etag {
						return nil, fmt.Errorf("soft delete matched no rows but etag unchanged: expected etag mismatch")
					}
					return nil, model.ErrChatETagChanged
				case pgx.ErrNoRows:
					return nil, model.ErrChatNotExist
				default:
					return nil, fmt.Errorf("getting etag: %v", getEtagErr)
				}
			}
			return nil, model.ErrChatNotExist
		}
		return nil, err
	}
	if row.WasAlreadyDeleted {
		return nil, model.ErrChatAlreadyDeleted
	}
	return &row.Chat, nil
}

func (s *Store) GetChat(ctx context.Context, organizationId, userId, chatId string) (*model.Chat, error) {
	query := `SELECT %s FROM chat WHERE organization_id = $1 AND user_id = $2 AND chat_id = $3`
	query = postgres.SelectQuery(query, ChatPostgresColumns)
	rows, err := s.client.Query(ctx, query, organizationId, userId, chatId)
	if err != nil {
		return nil, fmt.Errorf("getting chat: %w", err)
	}
	row, err := pgx.CollectOneRow(rows, pgx.RowToAddrOfStructByNameLax[model.Chat])
	if err != nil {
		if err == pgx.ErrNoRows {
			return nil, model.ErrChatNotExist
		}
		return nil, fmt.Errorf("collecting row: %w", err)
	}
	return row, nil
}

func (s *Store) ListChats(ctx context.Context, organizationId, userId string, showDeleted bool, whereClause, orderByClause, paginationClause string, columns []string, params ...any) ([]*model.Chat, error) {
	if columns == nil {
		columns = ChatPostgresColumns
	}

	if organizationId != "-" && organizationId != "" {
		whereClause = postgres.AddToWhereClause(whereClause, fmt.Sprintf("organization_id = $%d", len(params)+1))
		params = append(params, organizationId)
	}
	if userId != "-" && userId != "" {
		whereClause = postgres.AddToWhereClause(whereClause, fmt.Sprintf("user_id = $%d", len(params)+1))
		params = append(params, userId)
	}

	// Add delete_time filter to whereClause if not showing deleted
	if !showDeleted {
		whereClause = postgres.AddToWhereClause(whereClause, "delete_time IS NULL")
	}

	query := strings.ReplaceAll("SELECT %s FROM chat #where# #orderby# #pagination#", "#where#", whereClause)
	query = strings.ReplaceAll(query, "#orderby#", orderByClause)
	query = strings.ReplaceAll(query, "#pagination#", paginationClause)
	query = postgres.SelectQuery(query, columns)

	var chats []*model.Chat
	transactionFN := func(tx postgres.Tx) error {
		chats = nil
		rows, err := tx.Query(ctx, query, params...)
		if err != nil {
			if err == pgx.ErrNoRows {
				return nil
			}
			return fmt.Errorf("selecting chats: %w", err)
		}
		chats, err = pgx.CollectRows(rows, pgx.RowToAddrOfStructByNameLax[model.Chat])
		if err != nil {
			return fmt.Errorf("collecting rows: %w", err)
		}
		return nil
	}
	return chats, s.client.ExecuteTransaction(ctx, postgres.RepeatableRead, transactionFN)
}
